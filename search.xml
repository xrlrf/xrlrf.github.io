<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[软考复习：数据结构基础(1.1线性表)]]></title>
    <url>%2F2017%2F10%2F17%2F%E8%BD%AF%E8%80%83%E5%A4%8D%E4%B9%A0%EF%BC%9A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80-1-1%E7%BA%BF%E6%80%A7%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[1.1 线性表线性表的基本运算１. 查找运算 在线性表中查找具有给定键值的结点２. 插入运算 在线性表第i(0&lt;=i&lt;=n-1)个结点的前面或者后面插入一个新的结点 删除运算删除线性表的第i(0&lt;=i&lt;=n-1)个结点。４. 其他运算 统计线性表中节点的个数 输出线性表各节点的值 复制线性表 线性表分拆 线性表合并 线性表排序 按某种规则整理线性表 线性表的存储 顺序存储顺序存储通常用一个数组。优点：能随机存取线性表中的任何一个结点缺点：１，数组大小通常是固定的，不利于任意增加或减少线性表节点的个数 ２，插入和删除线性表的结点时，要移动数组中的其他元素，操作复杂 链式存储链式存储是用链表存储线性表优点：每个结点的实际存储位置是任意的，插入和删除操作方便，不需要移动表元缺点：１，每个节点增加了一个后继指针成分，增加了存储空间 ２，不便随机访问线性表的任一结点 在线性表中插入新结点 顺序存储 设线性表结点类型为整形，插入之前有n个结点，把值为x的结点插入线性表的第i个位置上 插入步骤为： 检查插入要求的有关参数的合理性 把原来的第n个结点到第i个结点依次往后移动一个数组元素位置 把新结点放在第i个位置上 修正线性表的结点个数 链式存储 在廉洁存储线性表中插入一个键值为x的新结点，分为如下４种情况 在某指针p所指结点之后插入 插在首结点之前，使待插入结点成为新的首结点 接在线性表的末尾 在有序链表中插入，使新的线性表任然有序 删除线性表的结点 顺序存储 删除步骤： 检查删除要求的有关参数的合理性 把原来第i+1个表元至第n个结点依次向前移动一个数组元素位置 修正线性表结点个数 链式存储 删除步骤： 如链表为空链表，则不执行删除操作 如链表的首结点的值为指定值，更改表的头指针为指向首结点的后继结点 在链表中寻找指定值的结点 将找到的结点删除 1.1.1 栈 顺序存储可以用顺序存储线性表来表示栈，为了指明当前执行插入和删除运算的栈顶位置，需要一个地址变量top指出栈顶结点在数组中的下标 链式存储可以用链表实现。 1.1.2 队列 具有先进先出的特征 顺序存储随着一系列进队和出队运算，会出现前端空着，而队列空间已用完的情况一种可行的方法是把队列中的结点一刀队列的前端，修改头指针和尾指针另一种更好的解决方法是采用循环队列 循环队列就是将队列数组的第一个元素与最后一个元素连接起来。由于其中会造成队空和队满的条件同为head==tail。因此可采用只剩下一个空闲结点，就认为队列已满 链式存储 1.1.3 稀疏矩阵如果一个矩阵的元素绝大部分都为零，则称为稀疏矩阵。若直接用一个二维数组表示稀疏矩阵会浪费大量的内存空间，通常采用三元组数组或者十字链表两种方法来表示稀疏矩阵 三元组数组 稀疏矩阵中的每个非零元素都用一个三元组来表示，即非零元素的 行号，列号，和他的值然后按照某种顺序将全部非零元素的三元组存入一个数组中 如果只对稀疏矩阵的某些单个元素进行处理，则宜采用三元组表示 相关代码为： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126//三元组数值有一个特点：那就是在不同位置上的行值相同的元素 //一定是按照列值升序出现的。 //三元组数值有一个特点：那就是在不同位置上的行值相同的元素 //一定是按照列值升序出现的。 #define _CRT_SECURE_NO_WARNINGS #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; typedef struct TRIPLE//三元组成员 &#123; int row; int col; int value; &#125;TRIPLE; typedef struct TRIPLE_HEAD//三元组头 &#123; int rowCount; int colCount; int elementCount; TRIPLE *values; &#125;TRIPLE_HEAD; TRIPLE_HEAD *initTriple(); void destoryTriple(TRIPLE_HEAD *triHd); void showTriple(TRIPLE_HEAD triHd); TRIPLE_HEAD *revange(TRIPLE_HEAD trip); TRIPLE_HEAD *revange(TRIPLE_HEAD trip) &#123; TRIPLE_HEAD *ntrip = NULL; //new int p,q,col; ntrip = (TRIPLE_HEAD *)malloc(sizeof(TRIPLE_HEAD)); ntrip-&gt;rowCount = trip.colCount; ntrip-&gt;colCount = trip.rowCount; ntrip-&gt;elementCount = trip.elementCount; ntrip-&gt;values = (TRIPLE *)malloc(sizeof(TRIPLE)*ntrip-&gt;elementCount); if(ntrip-&gt;elementCount != 0) &#123;// 有非零元素则转换 q = 0; for(col = 1;col &lt;=(trip.colCount);col++) &#123; for(p = 0;p &lt; (trip.elementCount);p++) &#123; if(trip.values[p].col == col)&#123; ntrip-&gt;values[q].row = trip.values[p].col; ntrip-&gt;values[q].col = trip.values[p].row; ntrip-&gt;values[q].value = trip.values[p].value; q++; &#125; &#125; &#125; return ntrip; &#125;&#125; void showTriple(TRIPLE_HEAD triHd) &#123; int i, j, t = 0; printf("\n"); for (i = 1; i &lt;= triHd.rowCount; i++) &#123; for (j = 1; j &lt;= triHd.colCount; j++) &#123; if (t &lt; triHd.elementCount &amp;&amp; i == triHd.values[t].row &amp;&amp; j == triHd.values[t].col)&#123; printf("%d ", triHd.values[t++].value); &#125; else&#123; printf("0 "); &#125; &#125; printf("\n"); &#125; &#125; void destoryTriple(TRIPLE_HEAD *triHd) &#123; free(triHd-&gt;values); free(triHd); &#125; TRIPLE_HEAD *initTriple() &#123; TRIPLE_HEAD *th; int row; int col; int value; int i; th = (TRIPLE_HEAD *)malloc(sizeof(TRIPLE_HEAD)); printf("请输入矩阵的阶数（行 列）:"); scanf("%d%d", &amp;th-&gt;rowCount, &amp;th-&gt;colCount); printf("请输入有效元素的个数:\n"); scanf("%d", &amp;th-&gt;elementCount); th-&gt;values = (TRIPLE *)malloc(sizeof(TRIPLE)* th-&gt;elementCount); for (i = 0; i &lt; th-&gt;elementCount; i++) &#123; printf("请输入第%d个元素(行 列 值)(共%d个):", i+1, th-&gt;elementCount); scanf("%d%d%d", &amp;row, &amp;col, &amp;value); th-&gt;values[i].row = row; th-&gt;values[i].col = col; th-&gt;values[i].value = value; &#125; return th; &#125; void main(void) &#123; TRIPLE_HEAD *trip, *revTrip; trip = initTriple(); showTriple(*trip); revTrip = revange(*trip); showTriple(*revTrip);//转置之后的稀疏矩阵 destoryTriple(trip); destoryTriple(revTrip); &#125; ２. 十字链表 在十字链表中，同一行的结点和同一列的结点分别顺序循环连接，每个结点既在他所在行的循环链表中又在他所在列的循环链表中 每个结点含有五个域 行号，列号，值，该结点所在行链表后继结点指针，所在列链表后继结点指针 为了处理方便，通常对每个行链表和列链表分别设置一个头结点，并把它们构成带表头结点的循环链表。 为了引用某行某列方便，全部行链表的表头结点和全部列链表的表头结点分别组成数组，这两个数组的首结点指针存于 一个十字链表的头结点中，最后由一个指针指向该头结点。 相关代码为： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; typedef struct Matrix_ELEMENT //稀疏矩阵成员，值 并指向下一个值 &#123; int row; int col; int value; struct Matrix_ELEMENT *rowLink; struct Matrix_ELEMENT *colLink; &#125;; typedef struct Matrix_ELEMENT MELEMENT; typedef MELEMENT *LINKS; //指向一行或者一列的指针 typedef struct CROSS_LINK &#123; int rowCount; int colCount; /*LINKS *rowLinks; LINKS *colLinks;*/ //上下两句等价 MELEMENT **rowLinks; MELEMENT **colLinks; &#125;CROSS_LINK; CROSS_LINK *initCrossLink(void); MELEMENT *findPreCol(MELEMENT *rowLink, int col); MELEMENT *findPreRow(MELEMENT *colLink, int row); void destroyCrossLink(CROSS_LINK *cross); void showCrossLink(CROSS_LINK *cross); void showCrossLink(CROSS_LINK *cross) &#123; int i, j; MELEMENT *p; //输出的技巧 printf("矩阵如下：\n"); for (i = 0; i &lt; cross-&gt;rowCount; i++) &#123; for (p = cross-&gt;rowLinks[i], j = 0; p; p = p-&gt;rowLink) &#123; while (j++ &lt; p-&gt;col) &#123; printf("0 "); &#125; printf("%d ", p-&gt;value); &#125; while (j++ &lt; cross-&gt;colCount) &#123; printf("0 "); &#125; printf("\n"); &#125; &#125; void destroyCrossLink(CROSS_LINK *cross) &#123; //先释放每行指针形成的链表 int i; MELEMENT *p; for (i = 0; i &lt; cross-&gt;rowCount; i++) &#123; while (p = cross-&gt;rowLinks[i]) &#123; p = cross-&gt;rowLinks[i]; cross-&gt;rowLinks[i] = p-&gt;rowLink; free(p); &#125; &#125; //再释放行链数组和列连数组 free(cross-&gt;colLinks); free(cross-&gt;rowLinks); //最后释放头 free(cross); &#125; MELEMENT *findPreRow(MELEMENT *colLink, int row) &#123; MELEMENT *p, *q = NULL; for (p = colLink; p &amp;&amp; row &gt;= p-&gt;row; p = p-&gt;colLink) &#123; q = p; &#125; return q; &#125; MELEMENT *findPreCol(MELEMENT *rowLink, int col) &#123; MELEMENT *p, *q = NULL; for (p = rowLink; p &amp;&amp; col &gt;= p-&gt;col; p = p-&gt;rowLink) &#123; q = p; &#125; return q; &#125; CROSS_LINK *initCrossLink() &#123; CROSS_LINK *head; MELEMENT *mElement, *q; int row, col; int value; printf("请输入稀疏矩阵的阶数（行 列）："); scanf("%d%d", &amp;row, &amp;col); head = (CROSS_LINK *)malloc(sizeof(CROSS_LINK)); head-&gt;rowCount = row; head-&gt;colCount = col; head-&gt;rowLinks = (LINKS *)calloc(sizeof(LINKS),row); head-&gt;colLinks = (MELEMENT **)calloc(sizeof(MELEMENT *), col); printf("请输入(行 列 值)(行值输入为-1，结束输入):"); scanf("%d%d%d", &amp;row, &amp;col, &amp;value); while (row != -1) //(row != EOF) &#123; //将row、col、he value的值对应到相应的元素 mElement = (MELEMENT *)calloc(sizeof(MELEMENT), 1); //mElement-&gt;rowLink = NULL; //mElement-&gt;colLink = NULL; mElement-&gt;row = row; mElement-&gt;col = col; mElement-&gt;value = value; if (head-&gt;rowLinks[row] == NULL) head-&gt;rowLinks[row] = mElement; else &#123; q = findPreCol(head-&gt;rowLinks[row], col); if (q == NULL) &#123; mElement-&gt;rowLink = head-&gt;rowLinks[row]; head-&gt;rowLinks[row] = mElement; &#125; else &#123; mElement-&gt;rowLink = q-&gt;rowLink; q-&gt;rowLink = mElement; &#125; &#125; if (head-&gt;colLinks[col] == NULL) head-&gt;colLinks[col] = mElement; else &#123; q = findPreRow(head-&gt;colLinks[col], row); if (q == NULL) &#123; mElement-&gt;colLink = head-&gt;colLinks[col]; head-&gt;colLinks[col] = mElement; &#125; else &#123; mElement-&gt;colLink = q-&gt;colLink; q-&gt;colLink = mElement; &#125; &#125; printf("请输入(行 列 值)(行值输入为-1，结束输入):"); scanf("%d%d%d", &amp;row, &amp;col, &amp;value); &#125; return head; &#125; void main(void) &#123; CROSS_LINK *cLink; cLink = initCrossLink(); showCrossLink(cLink); destroyCrossLink(cLink); system("pause"); &#125; 如果对稀疏矩阵某行或某列整体做某处理，可能会使原来为零的元素变为非零，而原来非零的元素变为零，对于这种场合，稀疏矩阵应该采用十字链表来表示 KMP算法相关代码为：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122#include &lt;stdio.h&gt; #include &lt;string.h&gt; int next[32] = &#123;-999&#125;; /* 返回模式串T在母串S中第pos个字符的位置 */ /* 调试小技巧 print x = value 或 set var x = value 可以改变gdb运行时变量的值 */ int index_BM(char *S, char *T, int pos) &#123; int i; int j; i = pos; j = 0; while ( (i &lt; strlen(S)) &amp;&amp; (j &lt; strlen(T)) ) &#123; if (S[i] == T[j]) &#123; i++; j++; &#125; else &#123; i = i - j + 1; j = 0; &#125; &#125; /* 注意strlen(T)意味着j的取值范围为0 ~ (strlen(T) - 1) */ if (strlen(T) == j) &#123; return i - strlen(T); &#125; else &#123; return -1; &#125; &#125; void get_next(char *T, int *next) &#123; int k = -1; int j = 0; next[j] = k; while (j &lt; strlen(T)) &#123; if ( (k == -1) || (T[j] == T[k]) ) //注意等号是==，而不是= &#123; ++k; // 注意是先加后使用 ++j; next[j] = k; &#125; else &#123; k = next[k]; &#125; &#125; &#125; int index_KMP(char *S, char *T, int pos) &#123; int i; int j; i = pos; j = 0; while ( (i &lt; strlen(S)) &amp;&amp; (j &lt; strlen(T)) ) &#123; /* j = -1 表示next[0], 说明失配处在模式串T的第0个字符。所以这里特殊处理，然后令i+1和j+1。*/ if ( (j == -1) || S[i] == T[j]) &#123; i++; j++; &#125; else &#123; j = next[j]; &#125; &#125; if (strlen(T) == j) &#123; return i - strlen(T); &#125; else &#123; return -1; &#125; &#125; void print_next(int next[], int n) &#123; int i; for (i = 0; i &lt; n; i++) &#123; printf("next[%d] = %d\n", i, next[i]); &#125; &#125; int main(void) &#123; char *s = "ababcabcacbab"; char *t = "abcac"; int pos = 0; int index; printf("================ BM ==============\n"); index = index_BM(s, t, pos); printf("index = %d\n", index); printf("================ KMP ==============\n"); get_next(t, next); print_next(next, strlen(t)); index = index_KMP(s, t, pos); printf("index = %d\n", index); &#125; 求next函数的值 123next[j] = 0 j = 1;next[j] = max&#123;k|1 &lt; k &lt; j,'p1p2...pk-1' = 'pj-k+1pj-k+2...pj-1'&#125;next[j] = 1 其他情况 树和二叉树 /** * RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS. * LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/ (function() { // DON'T EDIT BELOW THIS LINE var d = document, s = d.createElement('script'); s.src = 'https://https-xrlrf-github-io.disqus.com/embed.js'; s.setAttribute('data-timestamp', +new Date()); (d.head || d.body).appendChild(s); })(); Please enable JavaScript to view the comments powered by Disqus. window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-107582762-1');]]></content>
      <categories>
        <category>软考</category>
      </categories>
      <tags>
        <tag>数据结构 软件设计师</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++GUI Programming with QT学习笔记day01]]></title>
    <url>%2F2017%2F10%2F14%2FC-GUI-Programming-with-QT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0day01%2F</url>
    <content type="text"><![CDATA[1,从HelloQt开始 123456789#include &lt;QApplication&gt;#include &lt;QLabel&gt;int main(int argc, char *argv[])&#123; QApplication app(argc, argv); QLabel *label = new QLabel("Hello Qt!"); label-&gt;show(); return app.exec();&#125; 第一,二行:是代码中需要使用的类的头文件。在 Qt4 中,可以写成&lt;QApplication&gt;的 格式,当然也可写成“QApplication.h”。 第三行:是 main 函数的标准写法 第五行:创建一个 QApplication 对象,管理应用程序的资源。 第六行:QLabel 对象,QLabel 是一个 Qt 提供的小控件,显示一行文本。 第七行:显示 QLabel。 第八行:QApplication.exec(),让程序进入消息循环。等待可能的菜单,工具条,鼠标等 的输入,进行响应。 将以上代码放到名为 hello.cpp 中,保存,编译过程如下: qmake -project,qmake 命令创建 hello.pro,是平台无关的工程文件。 在 hello.pro 所在目录下,运行 make(unix)或者 nmake(windows)。 1234567mkdir Hellocd Hellovim hello.cppqmake -projectqmake Hello.promake./Hello 第 6 行代码还可以如下替换: 12QLabel *label = new QLabel("&lt;h2&gt;&lt;i&gt;Hello&lt;/i&gt; " "&lt;font color=red&gt;Qt!&lt;/font&gt;&lt;/h2&gt;"); 这里面包含了 html 文本,显示的字体,颜色会改变。 实际程序中,下面两行是比不可少的。 12QApplication app(argc, argv); return app.exec(); 2,连接信号和相应函数 1234567891011#include &lt;QApplication&gt;#include &lt;QPushButton&gt;int main(int argc, char *argv[])&#123; QApplication app(argc, argv); QPushButton *button = new QPushButton("Quit"); QObject::connect(button, SIGNAL(clicked()),&amp;app, SLOT(quit())); button-&gt;show(); return app.exec();&#125; 当有所动作或者状态改变,qt 的控件会发出消息(signal),例如,当点击按钮时, 按钮会发送 clicked()消息,这个消息可以连接到一个函数上(这个函数在这里成为 slot)。这样,当一个消息发送时, slot 函数可以自动执行。 在这个例子中,我们连接了按钮的 clicked 信号和 QApplication 的 quit 函数 3，控件排列 123456789101112131415161718192021222324#include &lt;QApplication&gt;#include &lt;QHBoxLayout&gt;#include &lt;QSlider&gt;#include &lt;QSpinBox&gt;int main(int argc, char *argv[])&#123; QApplication app(argc, argv); QWidget *window = new QWidget; window-&gt;setWindowTitle("Enter Your Age"); QSpinBox *spinBox = new QSpinBox; QSlider *slider = new QSlider(Qt::Horizontal); spinBox-&gt;setRange(0, 130); slider-&gt;setRange(0, 130); QObject::connect(spinBox, SIGNAL(valueChanged(int)),slider, SLOT(setValue(int))); QObject::connect(slider, SIGNAL(valueChanged(int)),spinBox, SLOT(setValue(int))); spinBox-&gt;setValue(35); QHBoxLayout *layout = new QHBoxLayout; layout-&gt;addWidget(spinBox); layout-&gt;addWidget(slider); window-&gt;setLayout(layout); window-&gt;show(); return app.exec();&#125; 程序中使用了三个控件:QSpinBox,QSlider 和 QWidget。QWidget 是这个程序的主窗 口。QSpinBox 和 QSlider 被放在 QWidget 中;他们是 QWidget 的 children。反过来, 我们也可以称 QWidget 是 QSpinBox 和 QSlider 的 parent。QWidget 没有 parent,因 为它是程序的顶层窗口。在 QWidget 及其子类的构造函数中,都有一个 QWidget*参数, 用来指定它们的父控件。 Qt 有三个主要的布局管理器: 123QHBoxLayout:水平排列控件。QVBoxLayout:垂直排列控件。QGridLayout:按矩阵方式排列控件 /** * RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS. * LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/ (function() { // DON'T EDIT BELOW THIS LINE var d = document, s = d.createElement('script'); s.src = 'https://https-xrlrf-github-io.disqus.com/embed.js'; s.setAttribute('data-timestamp', +new Date()); (d.head || d.body).appendChild(s); })(); Please enable JavaScript to view the comments powered by Disqus. window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-107582762-1');]]></content>
      <categories>
        <category>QT学习</category>
      </categories>
      <tags>
        <tag>QT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++GUI Programming with QT学习笔记day02]]></title>
    <url>%2F2017%2F10%2F14%2FC-GUI-Programming-with-QT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0day02%2F</url>
    <content type="text"><![CDATA[创建对话框派生对话框类 第一个例子是一个用 C++实现的查找对话框。我们把这个对话框实现为一个类,这样它就是一个独立的控件,并有自己的信号(signal)和 slot 函数类的源代码分别放在 finddialog.h 和 finddialog.cpp 中。 首先看 finddialog.h 的代码 123456789101112131415161718192021222324252627#ifndef FINDDIALOG_H#define FINDDIALOG_H#include &lt;QDialog&gt;class QCheckBox;class QLabel;class QLineEdit;class QPushButton;class FindDialog:public QDialog&#123; Q_OBJECTpublic: FindDialog(QWidget *parent = 0);signals: void findNext(const QString &amp;str,Qt::CaseSensitivity cs); void findPrevious(const QString &amp;str,Qt::CaseSensitivity cs);private slots: void findClicked(); void enableFindButton(const QString &amp;text);private: QLabel *label; QLineEdit *lineEdit; QCheckBox *caseCheckBox; QCheckBox *backwardCheckBox; QPushButton *findButton; QPushButton *closeButton;&#125;;#endif // FINDDIALOG_H 一共 27 行,第 1,2,27 行是为了避免头文件被多次包含。 第 3 行包含 QDialog 头文件,这个类从 QDialog 继承,QDialog 从 QWidget 继承。 第 10 行,Q_OBJECT 是一个宏定义,如果类里面用到了 signal 或者 slots,就要声明这个宏。 第 12 行, FindDialog(QWidget *parent = 0);构造函数是 Qt 控件类的标准格式,默认的父参数为 NULL,说明没有父控件。 第 13 行,signal 声明了这个对话框发出的两个信号,如果选择向前查找,那么对话框就发出 findPrevious()信号,否则,发出 findNext()信号。signal 也是一个宏,在编译之前,C++预处理把它变成标准的 c++代码。Qt::CaseSensitivity 是一个枚举类型,有Qt::CaseSensitive 和 Qt::CaseInsensitive 两个值。 在类的私有部分,声明有两个 slot 函数。为了实现这两个函数,需要用到对话框的其他控件的信息,所以保存了一些控件的指针。slot 关键字和 signal 一样,也是一个宏。对于私有成员变量,我们只是使用了它们的指针,没有对它们进行存取操作,编译器不需要知道它们的详细定义,所以只使用了这些类的前向声明。 下面看一下 finddialog.cpp 源文件代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;QtGui&gt;#include "finddialog.h"FindDialog::FindDialog(QWidget *parent):QDialog(parent)&#123; label = new QLabel(tr("Find &amp;what:")); lineEdit = new QLineEdit; label-&gt;setBuddy(lineEdit); caseCheckBox = new QCheckBox(tr("Match &amp;case")); backwardCheckBox = new QCheckBox(tr("Search &amp;backward")); findButton = new QPushButton(tr("&amp;Find")); findButton-&gt;setDefault(true); findButton-&gt;setEnabled(false); closeButton = new QPushButton(tr("Close")); connect(lineEdit,SIGNAL(textChanged(const QString &amp;)), this,SLOT(enableFindButton(const QString &amp;))); connect(findButton,SIGNAL(clicked()), this,SLOT(findClicked())); connect(closeButton,SIGNAL(clicked()), this,SLOT(close())); QHBoxLayout *topLeftLayout = new QHBoxLayout; topLeftLayout-&gt;addWidget(label); topLeftLayout-&gt;addWidget(lineEdit); QVBoxLayout *leftLayout = new QVBoxLayout; leftLayout-&gt;addLayout(topLeftLayout); leftLayout-&gt;addWidget(caseCheckBox); leftLayout-&gt;addWidget(backwardCheckBox); QVBoxLayout *rightLayout = new QVBoxLayout; rightLayout-&gt;addWidget(findButton); rightLayout-&gt;addWidget(closeButton); rightLayout-&gt;addStretch(); QHBoxLayout *mainLayout = new QHBoxLayout; mainLayout-&gt;addLayout(leftLayout); mainLayout-&gt;addLayout(rightLayout); setLayout(mainLayout); setWindowTitle(tr("Find")); setFixedHeight(sizeHint().height());&#125;void FindDialog::findClicked()&#123; QString text = lineEdit-&gt;text(); Qt::CaseSensitivity cs = caseCheckBox-&gt;isChecked()?Qt::CaseSensitive :Qt::CaseInsensitive; if(backwardCheckBox-&gt;isChecked())&#123; emit findPrevious(text,cs); &#125;else&#123; emit findNext(text,cs); &#125;&#125;void FindDialog::enableFindButton(const QString &amp;text)&#123; findButton-&gt;setEnabled(!text.isEmpty());&#125; 第四行，把parent参数传递给了基类的构造函数。然后创建子窗口部件。 使用tr()函数来包含字符串是一个很不错的习惯。在这些字符串中，使用了表示“与”操作的符号”&amp;”来表示快捷键。例如，在第11行创建了一个Find按钮，用户可在哪些支持快捷键的平台下通过 Alt+F 来激活它。 在第８行设置了行编辑器作为标签的伙伴。所谓”伙伴”就是一个窗口部件，它可以在按下标签的快捷键时接收焦点。所以当用户按下该标签的快捷键时，焦点就会移动到这个行编辑器上。 布局中既可以包含多个窗口部件，也可以包含其他子布局 当用户点击 findButton 按钮,findClicked()就会调用,根据 backwardCheckBox状态,他发出 findPrevious()或者 findNext()信号。emit 也是一个 Qt 的宏。当用户改变 lineEdit 中的文本, enableFindButton()slot 函数就会调用。如果输入了文本,那么让 findButton 有效,否则就无效。 深入信号和槽在目前有的例子中,我们已经连接了不同的信号和槽。实际使用中还要考虑如下一些规则: 一个信号可以连接到多个槽:connect(slider, SIGNAL(valueChanged(int)),spinBox, SLOT(setValue(int)));connect(slider, SIGNAL(valueChanged(int)),this,SLOT(updateStatusBarIndicator(int)));当信号发出后,槽函数都会被调用,但是调用的顺序是随机的,不确定的。 多个信号可以连接到一个槽connect(lcd, SIGNAL(overflow()), this, SLOT(handleMathError()));connect(calculator, SIGNAL(divisionByZero()),this, SLOT(handleMathError()));任何一个信号发出,槽函数都会执行。 一个信号可以和另一个信号相连connect(lineEdit, SIGNAL(textChanged(const QString &amp;)),this, SIGNAL(updateRecord(const QString &amp;)));第一个信号发出后,第二个信号也同时发送。除此之外,信号与信号连接上和信号和槽连接相同。 连接可以被删除disconnect(lcd, SIGNAL(overflow()),this, SLOT(handleMathError()));这个函数很少使用,一个对象删除后,Qt 自动删除这个对象的所有连接。 信号和槽函数必须有着相同的参数类型,这样信号和槽函数才能成功连接:12connect(ftp, SIGNAL(rawCommandReply(int, const QString &amp;)),this,SLOT(processReply(int, const QString &amp;))); 如果信号里的参数个数多于槽函数的参数,多余的参数被忽略:12connect(ftp, SIGNAL(rawCommandReply(int, const QString &amp;)),this,SLOT(checkErrorCode(int))); 如果参速类型不匹配,或者信号和槽不存在,在 debug 状态时,Qt 会在运行期间给出警告。如果信号和槽连接时包含了参数的名字,Qt 将会给出警告。 以前我们列举的例子中都是控件的信号和槽。但是信号和槽机制在 QObject 中就实现了,可以实现在任何从 QObject 继承的子类中。 /** * RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS. * LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/ (function() { // DON'T EDIT BELOW THIS LINE var d = document, s = d.createElement('script'); s.src = 'https://https-xrlrf-github-io.disqus.com/embed.js'; s.setAttribute('data-timestamp', +new Date()); (d.head || d.body).appendChild(s); })(); Please enable JavaScript to view the comments powered by Disqus. window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-107582762-1');]]></content>
      <categories>
        <category>QT学习</category>
      </categories>
      <tags>
        <tag>QT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript进阶篇]]></title>
    <url>%2F2017%2F10%2F11%2FJavaScript%E8%BF%9B%E9%98%B6%E7%AF%87%2F</url>
    <content type="text"><![CDATA[数组创建数组语法： 1var myarray=new Array(); 我们创建数组的同时，还可以为数组指定长度，长度可任意指定。 1var myarray= new Array(8); //创建数组，存储8个数据。 注意：1.创建的新数组是空数组，没有值，如输出，则显示undefined。2.虽然创建数组时，指定了长度，但实际上数组都是变长的，也就是说即使指定了长度为8，仍然可以将元素存储在规定长度以外。 下面创建一个数组，用于存储5个人的数学成绩。 123456var myarray=new Array(); //创建一个新的空数组myarray[0]=66; //存储第1个人的成绩myarray[1]=80; //存储第2个人的成绩myarray[2]=90; //存储第3个人的成绩myarray[3]=77; //存储第4个人的成绩myarray[4]=59; //存储第5个人的成绩 注意：数组每个值有一个索引号，从0开始。 我们还可以用简单的方法创建上面的数组和赋值： 第一种方法： 1var myarray = new Array(66,80,90,77,59);//创建数组同时赋值 第二种方法： 1var myarray = [66,80,90,77,59];//直接输入一个数组（称 “字面量数组”） 注意：数组存储的数据可以是任何类型（数字、字符、布尔值等） 如果我们想知道数组的大小，只需引用数组的一个属性length。Length属性表示数组的长度，即数组中元素的个数。 语法： 1myarray.length; //获得数组myarray的长度 注意：因为数组的索引总是由0开始，所以一个数组的上下限分别是：0和length-1。如数组的长度是5，数组的上下限分别是0和4。 123var arr=[55,32,5,90,60,98,76,54];//包含8个数值的数组arrdocument.write(arr.length); //显示数组长度8document.write(arr[7]); //显示第8个元素的值54 同时，JavaScript数组的length属性是可变的，这一点需要特别注意。 12arr.length=10; //增大数组的长度document.write(arr.length); //数组长度已经变为10 数组随元素的增加，长度也会改变，如下: 1234var arr=[98,76,54,56,76]; // 包含5个数值的数组document.write(arr.length); //显示数组的长度5arr[15]=34; //增加元素，使用索引为15,赋值为34alert(arr.length); //显示数组的长度16 1.二维数组的定义方法一 1234567var myarr=new Array(); //先声明一维for(var i=0;i&lt;2;i++)&#123; //一维长度为2 myarr[i]=new Array(); //再声明二维 for(var j=0;j&lt;3;j++)&#123; //二维长度为3 myarr[i][j]=i+j; // 赋值，每个数组元素的值为i+j &#125; &#125; 2.二维数组的定义方法二 1var Myarr = [[0 , 1 , 2 ],[1 , 2 , 3]] 3.赋值 1myarr[0][1]=5; //将5的值传入到数组中，覆盖原有值。 说明: myarr[0][1] ,0 表示表的行，1表示表的列。 判断switch语法:123456789101112131415switch(表达式)&#123;case值1: 执行代码块 1 break;case值2: 执行代码块 2 break;...case值n: 执行代码块 n break;default: 与 case值1 、 case值2...case值n 不同时执行的代码&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;Switch&lt;/title&gt; &lt;script type="text/javascript"&gt; var myscore = 6; switch(myscore) &#123; case 0: case 1: case 2: case 3: case 4: case 5: degree = "继续努力！"; document.write("评语："+degree+"&lt;br&gt;"); break; case 6: degree = "及格，加油！"; document.write("评语："+degree+"&lt;br&gt;"); break; case 7: degree = "凑合，奋进！"; document.write("评语："+degree+"&lt;br&gt;"); break; case 8: degree = "很棒，很棒!"; document.write("评语："+degree+"&lt;br&gt;"); break; case 9: case 10: degree = "高手，大牛！"; document.write("评语："+degree+"&lt;br&gt;"); break; &#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; for语句结构：1234for(初始化变量;循环条件;循环迭代)&#123; 循环语句 &#125; 假如，一个盒子里有6个球，我们每次取一个，重复从盒中取出球，直到球取完为止。 123456&lt;script type="text/javascript"&gt;var num=1;for (num=1;num&lt;=6;num++) //初始化值；循环条件；循环后条件值更新&#123; document.write("取出第"+num+"个球&lt;br /&gt;");&#125;&lt;/script&gt; ####while循环完成从盒子里取球的动作，每次取一个，共6个球。 12345678&lt;script type="text/javascript"&gt;var num=0; //初始化值while (num&lt;=6) //条件判断&#123; document.write("取出第"+num+"个球&lt;br /&gt;"); num=num+1; //条件值更新&#125;&lt;/script&gt; do-while我们试着输出5个数字。 123456789&lt;script type="text/javascript"&gt; num= 1; do &#123; document.write("数值为:" + num+"&lt;br /&gt;"); num++; //更新条件 &#125; while (num&lt;=5)&lt;/script&gt; break格式如下：123456for(初始条件;判断条件;循环后条件值更新)&#123; if(特殊情况) &#123;break;&#125; 循环代码&#125; continue123456for(初始条件;判断条件;循环后条件值更新)&#123; if(特殊情况) &#123; continue; &#125; 循环代码&#125; 函数有参数的函数12345function add2(x,y)&#123; sum = x + y; document.write(sum);&#125; 返回值的函数12345function add2(x,y)&#123; sum = x + y; return sum; //返回函数值,return后面的值叫做返回值。&#125; 还可以通过变量存储调用函数的返回值，代码如下: 1result = add2(3,4);//语句执行后,result变量中的值为7。 注意:函数中参数和返回值不只是数字，还可以是字符串等其它类型。 事件鼠标单击事件( onclick ）比如，我们单击按钮时，触发 onclick 事件，并调用两个数和的函数add2()。代码如下： 1234567891011121314151617&lt;html&gt;&lt;head&gt; &lt;script type="text/javascript"&gt; function add2()&#123; var numa,numb,sum; numa=6; numb=8; sum=numa+numb; document.write("两数和为:"+sum); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;form&gt; &lt;input name="button" type="button" value="点击提交" onclick="add2()" /&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; #### 鼠标经过事件（onmouseover） 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;onmouseover&lt;/title&gt; &lt;script type="text/javascript"&gt; function info()&#123; confirm("请输入姓名后，在单击确定！"); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;form&gt; 密码:&lt;input type="text" name="password"&gt; &lt;input type="button" name="button" value="确定" onmouseover="info()"&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 鼠标移开事件（onmouseout）1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;onmouseout&lt;/title&gt; &lt;script type="text/javascript"&gt; function message()&#123; confirm("不要离开，只要输入密码，再单击登录，就ok了"); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;form&gt; 密码：&lt;input type="text" name="password"&gt; &lt;input type="button" name="button" value="登录" onmouseout="message()"&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 光标聚焦事件（onfocus）当网页中的对象获得聚点时，执行onfocus调用的程序就会被执行。 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;onfocus&lt;/title&gt; &lt;script type="text/javascript"&gt; function message()&#123; alert("请输入姓名！"); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;form&gt; 姓名：&lt;input type="text" name="username" value="请输入姓名！" onfocus="message()"&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 失焦事件（onblur）onblur事件与onfocus是相对事件，当光标离开当前获得聚焦对象的时候，触发onblur事件，同时执行被调用的程序。 如下代码, 网页中有用户和密码两个文本框。当前光标在用户文本框内时（即焦点在文本框），在光标离开该文本框后（即失焦时），触发onblur事件，并调用函数message()。 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;onblur失焦事件&lt;/title&gt; &lt;script type="text/javascript"&gt; function message()&#123; alert("请确定已输入用户名后，在离开！"); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;form&gt; 用户：&lt;input type="text" name="username" value="请输入用户名！" onblur="message()"&gt; 密码：&lt;input type="password" name="password" value="请输入密码！"&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 内容选中事件（onselect）选中事件，当文本框或者文本域中的文字被选中时，触发onselect事件，同时调用的程序就会被执行。 如下代码,当选中用户文本框内的文字时，触发onselect 事件，并调用函数message()。 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;onselect&lt;/title&gt; &lt;script type="text/javascript"&gt; function message()&#123; alert("您触发了选中事件！"); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;form&gt; 用户：&lt;input type="text" name="username" value="请输入用户名" onselect="message()"&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 文本框内容改变事件（onchange）通过改变文本框的内容来触发onchange事件，同时执行被调用的程序。 如下代码,当用户将文本框内的文字改变后，弹出对话框“您改变了文本内容！”。 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;onchange&lt;/title&gt; &lt;script type="text/javascript"&gt; function message()&#123; alert("您改变了文本内容！"); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;form&gt; 用户：&lt;input type="text" name="username" value="请输入用户名！" onchange="message()"&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 加载事件（onload）事件会在页面加载完成后，立即发生，同时执行被调用的程序。注意： 1.加载页面时，触发onload事件，事件写在`&lt;body&gt;`标签内。 2.此节的加载页面，可理解为打开一个新页面时。 如下代码,当加载一个新页面时，弹出对话框“加载中，请稍等…”。 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;onload&lt;/title&gt; &lt;script type="text/javascript"&gt; function message()&#123; alert("加载中，请稍等。。。"); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body onload="message()"&gt; 欢迎学习JavaScript.&lt;/body&gt;&lt;/html&gt; 卸载事件（onunload）当用户退出页面时（页面关闭、页面刷新等），触发onUnload事件，同时执行被调用的程序。 注意：不同浏览器对onunload事件支持不同。 如下代码,当退出页面时，弹出对话框“您确定离开该网页吗？”。 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;onunload&lt;/title&gt; &lt;script type="text/javascript"&gt; window.onunload = onunload_message(); function onunload_message()&#123; alert("您确定离开该网页吗？"); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;欢迎学习JavaScript.&lt;/body&gt;&lt;/html&gt; 卸载事件 对象什么是对象JavaScript 中的所有事物都是对象，如:字符串、数值、数组、函数等，每个对象带有属性和方法。 对象的属性：反映该对象某些特定的性质的，如：字符串的长度、图像的长宽等； 对象的方法：能够在对象上执行的动作。例如，表单的“提交”(Submit)，时间的“获取”(getYear)等； JavaScript 提供多个内建对象，比如 String、Date、Array 等等，使用对象前先定义，如下使用数组对象： 1var objectName =new Array();//使用new关键字定义对象 或者 1var objectName =[]; 访问对象属性的语法: 1objectName.propertyName 如使用 Array 对象的 length 属性来获得数组的长度： 12var myarray=new Array(6);//定义数组对象var myl=myarray.length;//访问数组长度length属性 以上代码执行后，myl的值将是：6 访问对象的方法： 1objectName.methodName() 如使用string 对象的 toUpperCase() 方法来将文本转换为大写： 12var mystr="Hello world!";//创建一个字符串var request=mystr.toUpperCase(); //使用字符串对象方法 以上代码执行后，request的值是：HELLO WORLD! Date 日期对象日期对象可以储存任意一个日期，并且可以精确到毫秒数（1/1000 秒）。 定义一个时间对象 : 1var Udate=new Date(); 注意:使用关键字new，Date()的首字母必须大写。 使 Udate 成为日期对象，并且已有初始值：当前时间(当前电脑系统时间)。 如果要自定义初始值，可以用以下方法： 12var d = new Date(2012, 10, 1); //2012年10月1日var d = new Date('Oct 1, 2012'); //2012年10月1日 我们最好使用下面介绍的“方法”来严格定义时间。 访问方法语法：“&lt;日期对象&gt;.&lt;方法&gt;” Date对象中处理时间和日期的常用方法： 返回/设置年份方法get/setFullYear() 返回/设置年份，用四位数表示。 12345var mydate=new Date();//当前时间2014年3月6日document.write(mydate+"&lt;br&gt;");//输出当前时间document.write(mydate.getFullYear()+"&lt;br&gt;");//输出当前年份mydate.setFullYear(81); //设置年份document.write(mydate+"&lt;br&gt;"); //输出年份被设定为 0081年。 注意:不同浏览器， mydate.setFullYear(81)结果不同，年份被设定为 0081或81两种情况。 返回星期方法getDay() 返回星期，返回的是0-6的数字，0 表示星期天。如果要返回相对应“星期”，通过数组完成，代码如下: 12345678&lt;script type="text/javascript"&gt; var mydate=new Date();//定义日期对象 var weekday=["星期日","星期一","星期二","星期三","星期四","星期五","星期六"];//定义数组对象,给每个数组项赋值 var mynum=mydate.getDay();//返回值存储在变量mynum中 document.write(mydate.getDay());//输出getDay()获取值 document.write("今天是："+ weekday[mynum]);//输出星期几&lt;/script&gt; 返回/设置时间方法get/setTime() 返回/设置时间，单位毫秒数，计算从 1970 年 1 月 1 日零时到日期对象所指的日期的毫秒数。 如果将目前日期对象的时间推迟1小时，代码如下: 123456&lt;script type="text/javascript"&gt; var mydate=new Date(); document.write("当前时间："+mydate+"&lt;br&gt;"); mydate.setTime(mydate.getTime() + 60 * 60 * 1000); document.write("推迟一小时时间：" + mydate);&lt;/script&gt; 结果: 当前时间：Thu Mar 6 11:46:27 UTC+0800 2014 推迟一小时时间：Thu Mar 6 12:46:27 UTC+0800 2014 注意: 一小时 60 分，一分 60 秒，一秒 1000 毫秒 时间推迟 1 小时,就是: “x.setTime(x.getTime() + 60 60 1000);” String 字符串对象 方法名 功能 charAt() 返回指定位置的字符 indexOf() 返回指定字符首次出现的位置 split() 字符串分割 substring() 提取字符串 substr() 提取指定数目的字符串 1.访问字符串对象的属性length: 12var mystr="Hello World!";var myl=mystr.length; 以上代码执行后，myl 的值将是：12 2.访问字符串对象的方法： 使用 String 对象的 toUpperCase() 方法来将字符串小写字母转换为大写： 12var mystr="Hello world!";var mynum=mystr.toUpperCase(); 以上代码执行后，mynum 的值是：HELLO WORLD! 返回指定位置的字符charAtcharAt() 方法可返回指定位置的字符。返回的字符是长度为 1 的字符串。 语法:1stringObject.charAt(index) 参数说明： 注意：1.字符串中第一个字符的下标是 0。最后一个字符的下标为字符串长度减一（string.length-1）。 2.如果参数 index 不在 0 与 string.length-1 之间，该方法将返回一个空字符串。 如:在字符串 “I love JavaScript!” 中，返回位置2的字符： 1234&lt;script type="text/javascript"&gt; var mystr="I love JavaScript!" document.write(mystr.charAt(2));&lt;/script&gt; 注意：一个空格也算一个字符。 返回指定的字符串首次出现的位置(indexOf)indexOf() 方法可返回某个指定的字符串值在字符串中首次出现的位置。 语法 1stringObject.indexOf(substring, startpos) 参数说明： 说明： 1.该方法将从头到尾地检索字符串 stringObject，看它是否含有子串 substring。 2.可选参数，从stringObject的startpos位置开始查找substring，如果没有此参数将从stringObject的开始位置查找。 3.如果找到一个 substring，则返回 substring 的第一次出现的位置。stringObject 中的字符位置是从 0 开始的。 注意： indexOf() 方法区分大小写。 如果要检索的字符串值没有出现，则该方法返回 -1。 例如: 对 “I love JavaScript!” 字符串内进行不同的检索： 123456&lt;script type="text/javascript"&gt; var str="I love JavaScript!" document.write(str.indexOf("I") + "&lt;br /&gt;"); document.write(str.indexOf("v") + "&lt;br /&gt;"); document.write(str.indexOf("v",8));&lt;/script&gt; 以上代码的输出： 123049 字符串分割split()知识讲解： split() 方法将字符串分割为字符串数组，并返回此数组。 语法： 1stringObject.split(separator,limit) 参数说明: 注意：如果把空字符串 (“”) 用作 separator，那么 stringObject 中的每个字符之间都会被分割。 我们将按照不同的方式来分割字符串： 使用指定符号分割字符串，代码如下: 123var mystr = "www.imooc.com";document.write(mystr.split(".")+"&lt;br&gt;");document.write(mystr.split(".", 2)+"&lt;br&gt;"); 运行结果: 12www,imooc,comwww,imooc 将字符串分割为字符，代码如下： 12document.write(mystr.split("")+"&lt;br&gt;");document.write(mystr.split("", 5)); 运行结果: 12w,w,w,.,i,m,o,o,c,.,c,o,mw,w,w,.,i 提取字符串substring()substring用于提取字符串中介于两个指定下标之间的字符 语法： 1stringObject.substring(startPos,stopPos) 参数说明 参数 描述 startPos 必需。一个非负的整数，开始位置 stopPos 可选。一个非负的整数，结束位置，如果省略该参数，那么返回的子串会一直到字符串对象的结尾。 注意： 返回的内容是从 start开始(包含start位置的字符)到 stop-1 处的所有字符，其长度为 stop 减start。 如果参数 start 与 stop 相等，那么该方法返回的就是一个空串（即长度为 0 的字符串）。 如果 start 比 stop 大，那么该方法在提取子串之前会先交换这两个参数。 使用 substring() 从字符串中提取字符串，代码如下： 12345&lt;script type="text/javascript"&gt; var mystr="I love JavaScript"; document.write(mystr.substring(7)); document.write(mystr.substring(2,6));&lt;/script&gt; 运行结果: 12JavaScriptlove 提取指定数目的字符substr()substr() 方法从字符串中提取从 startPos位置开始的指定数目的字符串。 语法: 1stringObject.substr(startPos,length) 参数说明: 注意：如果参数startPos是负数，从字符串的尾部开始算起的位置。也就是说，-1 指字符串中最后一个字符，-2指倒数第二个字符，以此类推。 如果startPos为负数且绝对值大于字符串长度，startPos为0。 使用 substr() 从字符串中提取一些字符，代码如下： 12345&lt;script type="text/javascript"&gt; var mystr="I love JavaScript!"; document.write(mystr.substr(7)); document.write(mystr.substr(2,4));&lt;/script&gt; 运行结果： 12JavaScript!love Math对象Math对象，提供对数据的数学计算。 使用 Math 的属性和方法，代码如下： 123456&lt;script type="text/javascript"&gt; var mypi=Math.PI; var myabs=Math.abs(-15); document.write(mypi); document.write(myabs);&lt;/script&gt; 运行结果: 123.14159265358979315 注意：Math 对象是一个固有的对象，无需创建它，直接把 Math作为对象使用就可以调用其所有属性和方法。这是它与Date,String对象的区别。 Math 对象属性 属性 说明 E 返回算数常量e,即自然对数的底数（约等于2.718…） LN2 返回２的自然对数（约等于０.693） LN10 返回１０的自然对数（约等于2.302）｜ LOG2E 返回以２为底的e的对数（约等于1.442） LOG10E 返回以１０为底的e的对数（约等于0.434） PI 返回圆周率 (约等于3.14159) SQRT1_2 返回２的平方根的倒数（约等于0.707） SQRT2 返回2的平方根（约等于1.414）｜ Math 对象方法 方法 描述 abs(x) 返回数的绝对值 acos(x) 返回数的反余弦值 asin(x) 返回数的反正弦值 atan(x) 返回数的反正切值 atan2(y,x) 返回由x轴到点(x,y)的角度（以弧度为单位） ceil(x) 对数进行上舍入 cos(x) 返回数的余弦 exp(x) 返回e的指数 floor(x) 对数进行下舍入 log(x) 返回数的自然对数（底为e） max(x,y) 返回x和y的最大值 min(x,y) 返回x和y的最小值 pow(x,y) 返回x的y次幂 random() 返回０～１之间的随机数 round(x) 把数四舍五入为最接近的整数 sin(x) 返回数的正弦 sqrt() 返回数的平方根 tan(x) 返回角的正切 toSource() 返回该对象的源代码 valueOf() 返回Math对象的原始值 向上取整ceil()ceil() 方法可对一个数进行向上取整。 语法:1Math.ceil(x) 参数说明: 参数 描述 x 必需，必须是一个数值 注意：它返回的是大于或等于x，并且与x最接近的整数。 我们将把 ceil() 方法运用到不同的数字上，代码12345678&lt;script type="text/javascript"&gt; document.write(Math.ceil(0.8) + "&lt;br /&gt;") document.write(Math.ceil(6.3) + "&lt;br /&gt;") document.write(Math.ceil(5) + "&lt;br /&gt;") document.write(Math.ceil(3.5) + "&lt;br /&gt;") document.write(Math.ceil(-5.1) + "&lt;br /&gt;") document.write(Math.ceil(-5.9))&lt;/script&gt; 运行结果：1234561754-5-5 随机数 random()random() 方法可返回介于 0 ~ 1（大于或等于 0 但小于 1 )之间的一个随机数。语法： 1Math.random(); 注意：返回一个大于或等于 0 但小于 1 的符号为正的数字值。 我们取得介于 0 到 1 之间的一个随机数，代码如下： 123&lt;script type="text/javascript"&gt; document.write(Math.random());&lt;/script&gt; 运行结果： 10.190305486195328 注意:因为是随机数，所以每次运行结果不一样，但是0 ~ 1的数值。获得0 ~ 10之间的随机数，代码如下: 123&lt;script type="text/javascript"&gt; document.write((Math.random())*10);&lt;/script&gt; 运行结果： 18.72153625893887 Array 数组对象数组对象是一个对象的集合，里边的对象可以是不同类型的。数组的每一个成员对象都有一个“下标”，用来表示它在数组中的位置，是从零开始的 数组定义的方法： 定义了一个空数组: 1var 数组名= new Array(); 定义时指定有n个空元素的数组： 1var 数组名 =new Array(n); 3.定义数组的时候，直接初始化数据： 1var 数组名 = [&lt;元素1&gt;, &lt;元素2&gt;, &lt;元素3&gt;...]; 我们定义myArray数组，并赋值，代码如下： 1var myArray = [2, 8, 6]; 数组属性： length 用法：&lt;数组对象&gt;.length； 数组方法： 方法 描述 concat() 连接两个数组或更多的数组，并返回结果 join() 把数组的所有元素放入一个字符串。元素通过指定的分隔符进行分隔 pop() 删除并返回数组的最后一个元素 push() 向数组的末尾添加一个或更多元素，并返回新的长度 reverse() 颠倒数组中元素的顺序 shift() 删除并返回数组的第一个元素 slice() 从某个已有的数组返回选定的元素 sort() 对数组的元素进行排序 splice() 删除元素，并向数组添加新元素 toSource() 返回该对象的源代码 toString() 把数组转换为字符串，并返回结果 toLocaleString() 把数组转换为本地数组，并返回结果 unshift() 向数组的开头添加一个或多个元素，并返回新的长度 valueOf() 返回数组元素的原始值 数组连接concat()concat() 方法用于连接两个或多个数组。此方法返回一个新数组，不改变原来的数组。 语法 1arrayObject.concat(array1,array2,...,arrayN) 注意: 该方法不会改变现有的数组，而仅仅会返回被连接数组的一个副本。 我们创建一个数组，将把 concat() 中的参数连接到数组 myarr 中，代码如下： 参数说明： 12345678&lt;script type="text/javascript"&gt; var mya = new Array(3); mya[0] = "1"; mya[1] = "2"; mya[2] = "3"; document.write(mya.concat(4,5)+"&lt;br&gt;"); document.write(mya);&lt;/script&gt; 运行结果： 121,2,3,4,51,2,3 我们创建了三个数组，然后使用 concat() 把它们连接起来，代码如下： 1234567&lt;script type="text/javascript"&gt; var mya1= new Array("hello!") var mya2= new Array("I","love"); var mya3= new Array("JavaScript","!"); var mya4=mya1.concat(mya2,mya3); document.write(mya4);&lt;/script&gt; 运行结果： 1hello!,I,love,JavaScript,! 指定分隔符连接数组元素join()join()方法用于把数组中的所有元素放入一个字符串。元素是通过指定的分隔符进行分隔的。语法： 1arrayObject.join(分隔符) 参数说明: 参数 描述 separator 可选，指定要使用的分隔符，若省略，则使用逗号作为分隔符 注意：返回一个字符串，该字符串把数组中的各个元素串起来，用&lt;分隔符&gt;置于元素与元素之间。这个方法不影响数组原本的内容。 我们使用join（）方法，将数组的所有元素放入一个字符串中，代码如下： 1234567&lt;script type="text/javascript"&gt; var myarr = new Array(3); myarr[0] = "I"; myarr[1] = "love"; myarr[2] = "JavaScript"; document.write(myarr.join());&lt;/script&gt; 运行结果：1I,love,JavaScript 颠倒数组元素顺序reverse()reverse() 方法用于颠倒数组中元素的顺序。 语法： 1arrayObject.reverse() 注意：该方法会改变原来的数组，而不会创建新的数组。 定义数组myarr并赋值，然后颠倒其元素的顺序： 12345678&lt;script type="text/javascript"&gt; var myarr = new Array(3) myarr[0] = "1" myarr[1] = "2" myarr[2] = "3" document.write(myarr + "&lt;br /&gt;") document.write(myarr.reverse())&lt;/script&gt; 运行结果： 121,2,33,2,1 选定元素slice()slice() 方法可从已有的数组中返回选定的元素。 语法 1arrayObject.slice(start,end) 参数说明： 1.返回一个新的数组，包含从 start 到 end （不包括该元素）的 arrayObject 中的元素。 该方法并不会修改数组，而是返回一个子数组。 注意： 可使用负值从数组的尾部选取元素。 如果 end 未被规定，那么 slice() 方法会选取从 start 到数组结尾的所有元素。 String.slice() 与 Array.slice() 相似。 我们将创建一个新数组，然后从其中选取的元素，代码如下： 123456&lt;script type="text/javascript"&gt; var myarr = new Array(1,2,3,4,5,6); document.write(myarr + "&lt;br&gt;"); document.write(myarr.slice(2,4) + "&lt;br&gt;"); document.write(myarr);&lt;/script&gt; 运行结果： 1231,2,3,4,5,63,41,2,3,4,5,6 数组排序(sort)sort()方法使数组中的元素按照一定的顺序排列 语法： 1arrayObject.sort(方法函数) 参数说明： 参数 描述 方法函数 可选。规定顺序排序。必须是函数 如果不指定&lt;方法函数&gt;，则按unicode码顺序排列 如果指定&lt;方法函数&gt;,则按&lt;方法函数&gt;所指定的排序方法排序 注意：该函数要比较两个值，然后返回一个用于说明这两个值相对顺序的数字。比较函数应该具有两个参数a和b,其返回值如下。若返回值 &lt;= -1,则表示A在排序后的序列中出现在Ｂ之前若返回值 &gt; -1 ＆＆ &lt; 1，则表示A和Ｂ具有相同的排序顺序若返回子 &gt;= 1 ,则表示Ａ在排序后的序列中出现在Ｂ之后 １，使用sort将数组进行排序 123456&lt;script type="text/javascript"&gt;var myarr1 = new Array("Hello","John","love","JavaScript");var myarr2 = new Array("80","16","50","6","100","1");document.write(myarr1.sort()+"&lt;br&gt;");document.write(myarr2.sort());&lt;/script&gt; 运行结果：12Hello,JavaScript,John,love1,100,16,50,6,80 注意:上面的代码没有按照数值的大小对数字进行排序。 2.如要实现这一点，就必须使用一个排序函数，代码123456789&lt;script type="text/javascript"&gt; function sortNum(a,b) &#123; return a - b; //升序，如降序，把“a - b”该成“b - a”&#125; var myarr = new Array("80","16","50","6","100","1"); document.write(myarr + "&lt;br&gt;"); document.write(myarr.sort(sortNum));&lt;/script&gt; 运行结果：1280,16,50,6,100,11,6,16,50,80,100 浏览器对象window对象 JavaScript 计时器在JavaScript中，我们可以在设定的时间间隔之后来执行代码，而不是在函数被调用后立即执行。 计时器类型： 一次性计时器：仅在指定的延迟时间之后触发一次。间隔性触发计时器：每隔一定的时间间隔就触发一次。 计时器setInterval()在执行时,从载入页面后每隔指定的时间执行代码。 setInterval(代码,交互时间); 代码：要调用的函数或要执行的代码串。 交互时间：周期性执行或调用表达式之间的时间间隔，以毫秒计（1s=1000ms）。 返回值: 一个可以传递给 clearInterval() 从而取消对”代码”的周期性执行的值。 调用函数格式(假设有一个clock()函数):1setInterval("clock()",1000) 或1setInterval(clock,1000) 我们设置一个计时器，每隔100毫秒调用clock()函数，并将时间显示出来，代码如下: 12345678910111213141516171819&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt;&lt;title&gt;计时器&lt;/title&gt;&lt;script type="text/javascript"&gt; var int=setInterval(clock, 100) function clock()&#123; var time=new Date(); document.getElementById("clock").value = time; &#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;form&gt; &lt;input type="text" id="clock" size="50" /&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 取消计时器clearInterval()clearInterval() 方法可取消由 setInterval() 设置的交互时间。 语法： 1clearInterval(id_of_setInterval) 参数说明: id_of_setInterval：由 setInterval() 返回的 ID 值。 每隔 100 毫秒调用 clock() 函数,并显示时间。当点击按钮时，停止时间,代码如下: 123456789101112131415161718192021&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt;&lt;title&gt;计时器&lt;/title&gt;&lt;script type="text/javascript"&gt; function clock()&#123; var time=new Date(); document.getElementById("clock").value = time; &#125;// 每隔100毫秒调用clock函数，并将返回值赋值给i var i=setInterval("clock()",100);&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;form&gt; &lt;input type="text" id="clock" size="50" /&gt; &lt;input type="button" value="Stop" onclick="clearInterval(i)" /&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 计时器setTimeout()setTimeout()计时器，在载入后延迟指定时间后,去执行一次表达式,仅执行一次。 语法: 1setTimeout(代码,延迟时间); 参数说明： 要调用的函数或要执行的代码串。 延时时间：在执行代码前需等待的时间，以毫秒为单位（1s=1000ms)。 当我们打开网页3秒后，在弹出一个提示框，代码如下: 12345678910&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;&lt;script type="text/javascript"&gt; setTimeout("alert('Hello!')", 3000 );&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 当按钮start被点击时，setTimeout()调用函数，在5秒后弹出一个提示框。 123456789101112131415&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;&lt;script type="text/javascript"&gt;function tinfo()&#123; var t=setTimeout("alert('Hello!')",5000); &#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;form&gt; &lt;input type="button" value="start" onClick="tinfo()"&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 要创建一个运行于无穷循环中的计数器，我们需要编写一个函数来调用其自身。在下面的代码，当按钮被点击后，输入域便从0开始计数。 12345678910111213141516171819&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;&lt;script type="text/javascript"&gt;var num=0;function numCount()&#123; document.getElementById('txt').value=num; num=num+1; setTimeout("numCount()",1000); &#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;form&gt;&lt;input type="text" id="txt" /&gt;&lt;input type="button" value="Start" onClick="numCount()" /&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 取消计时器clearTimeout()setTimeout()和clearTimeout()一起使用，停止计时器。 语法: 1clearTimeout(id_of_setTimeout) 参数说明: id_of_setTimeout：由 setTimeout() 返回的 ID 值。该值标识要取消的延迟执行代码块。 下面的例子和上节的无穷循环的例子相似。唯一不同是，现在我们添加了一个 “Stop” 按钮来停止这个计数器： 1234567891011121314151617181920212223&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;&lt;script type="text/javascript"&gt; var num=0,i; function timedCount()&#123; document.getElementById('txt').value=num; num=num+1; i=setTimeout(timedCount,1000); &#125; setTimeout(timedCount,1000); function stopCount()&#123; clearTimeout(i); &#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;form&gt; &lt;input type="text" id="txt"&gt; &lt;input type="button" value="Stop" onClick="stopCount()"&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; History 对象history对象记录了用户曾经浏览过的页面(URL)，并可以实现浏览器前进与后退相似导航的功能。 注意:从窗口被打开的那一刻开始记录，每个浏览器窗口、每个标签页乃至每个框架，都有自己的history对象与特定的window对象关联。 语法： window.history.[属性|方法]注意：window可以省略。 History 对象属性 History 对象方法 使用length属性，当前窗口的浏览历史总长度，代码如下： 1234&lt;script type="text/javascript"&gt; var HL = window.history.length; document.write(HL);&lt;/script&gt; 返回前一个浏览的页面 back()方法，加载 history 列表中的前一个 URL。 语法： 1window.history.back(); 比如，返回前一个浏览的页面，代码如下： 1window.history.back(); 注意：等同于点击浏览器的倒退按钮。 back()相当于go(-1),代码如下: 1window.history.go(-1); 返回下一个浏览的页面 forward()方法，加载 history 列表中的下一个 URL。 如果倒退之后，再想回到倒退之前浏览的页面，则可以使用forward()方法,代码如下:1window.history.forward(); 注意：等价点击前进按钮。 forward()相当于go(1),代码如下: 1window.history.go(1); 返回浏览历史中的其他页面go()方法，根据当前所处的页面，加载 history 列表中的某个具体的页面。 语法： window.history.go(number);参数： 浏览器中，返回当前页面之前浏览过的第二个历史页面，代码如下：1window.history.go(-2); 注意：和在浏览器中单击两次后退按钮操作一样。 同理，返回当前页面之后浏览过的第三个历史页面，代码如下： 1window.history.go(3); location对象location用于获取或设置窗体的URL，并且可以用于解析URL。 语法: 1location.[属性|方法] location对象属性图示: location 对象属性： 属性 描述 hash 设置或返回从’#’开始的URL(锚) host 设置或返回主机名和当前URL的端口号 hostname 设置或返回当前URL的主机名 href 设置或返回完整的URL pathname 设置或返回当前URL的路径部分 port 设置或返回当前URL的端口号 protocol 设置或返回当前URL的协议 search 设置或返回从’?’开始的URL(查询部分) location 对象方法: 属性 描述 assign() 加载新的文档 reload() 重新加载当前文档 replace() 用新的文档替换当前文档 Navigator对象Navigator 对象包含有关浏览器的信息，通常用于检测浏览器与操作系统的版本。 对象属性: 查看浏览器的名称和版本，代码如下: 1234567&lt;script type="text/javascript"&gt; var browser=navigator.appName; var b_version=navigator.appVersion; document.write("Browser name"+browser); document.write("&lt;br&gt;"); document.write("Browser version"+b_version);&lt;/script&gt; userAgent返回用户代理头的字符串表示(就是包括浏览器版本信息等的字符串) 语法1navigator.userAgent 几种浏览的user_agent.，像360的兼容模式用的是IE、极速模式用的是chrom的内核。 使用userAgent判断使用的是什么浏览器(假设使用的是IE8浏览器),代码如下: 12345678910111213function validB()&#123; var u_agent = navigator.userAgent; var B_name="Failed to identify the browser"; if(u_agent.indexOf("Firefox")&gt;-1)&#123; B_name="Firefox"; &#125;else if(u_agent.indexOf("Chrome")&gt;-1)&#123; B_name="Chrome"; &#125;else if(u_agent.indexOf("MSIE")&gt;-1&amp;&amp;u_agent.indexOf("Trident")&gt;-1)&#123; B_name="IE(8-10)"; &#125; document.write("B_name:"+B_name+"&lt;br&gt;"); document.write("u_agent:"+u_agent+"&lt;br&gt;");&#125; screen对象screen对象用于获取用户的屏幕信息。 语法： 1window.screen.属性 对象属性: 屏幕分辨率的高和宽window.screen 对象包含有关用户屏幕的信息。 screen.height 返回屏幕分辨率的高 screen.width 返回屏幕分辨率的宽 注意: 单位以像素计。 window.screen 对象在编写时可以不使用 window 这个前缀。 我们来获取屏幕的高和宽，代码如下: 1234&lt;script type="text/javascript"&gt; document.write( "屏幕宽度："+screen.width+"px&lt;br /&gt;" ); document.write( "屏幕高度："+screen.height+"px&lt;br /&gt;" );&lt;/script&gt; 屏幕可用高和宽度 screen.availWidth 属性返回访问者屏幕的宽度，以像素计，减去界面特性，比如任务栏。 screen.availHeight 属性返回访问者屏幕的高度，以像素计，减去界面特性，比如任务栏。 注意: 不同系统的任务栏默认高度不一样，及任务栏的位置可在屏幕上下左右任何位置，所以有可能可用宽度和高度不一样。 我们来获取屏幕的可用高和宽度，代码如下： 1234&lt;script type="text/javascript"&gt;document.write("可用宽度：" + screen.availWidth);document.write("可用高度：" + screen.availHeight);&lt;/script&gt; 注意:根据屏幕的不同显示值不同。 DOM文档对象模型DOM（Document Object Model）定义访问和处理HTML文档的标准方法。DOM 将HTML文档呈现为带有元素、属性和文本的树结构（节点树）。 先来看看下面代码: 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;DOM&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h2&gt;&lt;a href="http://www.imooc.com"&gt;javascript DOM&lt;/a&gt;&lt;/h2&gt; &lt;p&gt;对HTML元素进行操作，可添加，改变或移除CSS样式等&lt;/p&gt; &lt;ul&gt; &lt;li&gt;JavaScript&lt;/li&gt; &lt;li&gt;DOM&lt;/li&gt; &lt;li&gt;CSS&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 将HTML代码分解为DOM节点层次图: HTML文档可以说由节点构成的集合，DOM节点有: 元素节点：上图中&lt;html&gt;、&lt;body&gt;、&lt;p&gt;等都是元素节点，即标签。 文本节点:向用户展示的内容，如&lt;li&gt;...&lt;/li&gt;中的JavaScript、DOM、CSS等文本。 属性节点:元素属性，如&lt;a&gt;标签的链接属性href=”http://www.imooc.com&quot;。 节点属性: 遍历节点树: 以上图ul为例，它的父级节点body,它的子节点3个li,它的兄弟结点h2、P。 DOM操作: 注意:前两个是document方法。 getElementsByName()方法返回带有指定名称的节点对象的集合。 语法：1document.getElementsByName(name) 与getElementById() 方法不同的是，通过元素的 name 属性查询元素，而不是通过 id 属性。 注意: 因为文档中的 name 属性可能不唯一，所有 getElementsByName() 方法返回的是元素的数组，而不是一个元素。 和数组类似也有length属性，可以和访问数组一样的方法来访问，从0开始。 看看下面的代码: 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;getElementsByName&lt;/title&gt; &lt;script type="text/javascript"&gt; function getElements()&#123; var x = document.getElementsByName("alink"); alert(x.length); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;a href="" name="alink"&gt;我是链接一&lt;/a&gt; &lt;a href="" name="alink"&gt;我是连接二&lt;/a&gt; &lt;a href="" name="alink"&gt;我是链接三&lt;/a&gt; &lt;/br&gt; &lt;input type="button" onclick="getElements()" value="看看几个链接？"&gt;&lt;/body&gt;&lt;/html&gt; getElementsByTagName()方法返回带有指定标签名的节点对象的集合。返回元素的顺序是它们在文档中的顺序。 语法: 1document.getElementsByTagName(Tagname) 说明: Tagname是标签的名称，如p、a、img等标签名。 和数组类似也有length属性，可以和访问数组一样的方法来访问，所以从0开始。 看看下面代码，通过getElementsByTagName()获取节点。 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;getElementsByTagName&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p id="intro"&gt;我的课程&lt;/p&gt; &lt;ul&gt; &lt;li&gt;JavaScript&lt;/li&gt; &lt;li&gt;JQuery&lt;/li&gt; &lt;li&gt;HTML&lt;/li&gt; &lt;li&gt;JAVA&lt;/li&gt; &lt;li&gt;PHP&lt;/li&gt; &lt;/ul&gt; &lt;script type="text/javascript"&gt; // 获取所有的li集合 var list = document.getElementsByTagName('li'); // 访问无序列表：[0]索引 li = list[0]; // 获取list长度 document.write(list.length); // 弹出li节点对象的内容 document.write(li.innerHTML); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 区别getElementByID,getElementsByName,getElementsByTagName以人来举例说明，人有能标识身份的身份证，有姓名，有类别(大人、小孩、老人)等。 ID 是一个人的身份证号码，是唯一的。所以通过getElementById获取的是指定的一个人。 Name 是他的名字，可以重复。所以通过getElementsByName获取名字相同的人集合。 TagName可看似某类，getElementsByTagName获取相同类的人集合。如获取小孩这类人，getElementsByTagName(“小孩”)。 把上面的例子转换到HTML中，如下:1&lt;input type="checkbox" name="hobby" id="hobby1"&gt; 音乐 input标签就像人的类别。name属性就像人的姓名。id属性就像人的身份证。 方法总结如下: 注意：方法区分大小写 通过下面的例子(6个name=”hobby”的复选项，两个按钮)来区分三种方法的不同: 12345678&lt;input type="checkbox" name="hobby" id="hobby1"&gt; 音乐&lt;input type="checkbox" name="hobby" id="hobby2"&gt; 登山&lt;input type="checkbox" name="hobby" id="hobby3"&gt; 游泳&lt;input type="checkbox" name="hobby" id="hobby4"&gt; 阅读&lt;input type="checkbox" name="hobby" id="hobby5"&gt; 打球&lt;input type="checkbox" name="hobby" id="hobby6"&gt; 跑步&lt;input type="button" value = "全选" id="button1"&gt;&lt;input type="button" value = "全不选" id="button1"&gt; document.getElementsByTagName(“input”)，结果为获取所有标签为input的元素，共8个。 document.getElementsByName(“hobby”)，结果为获取属性name=”hobby”的元素，共6个。 document.getElementById(“hobby6”)，结果为获取属性id=”hobby6”的元素，只有一个，”跑步”这个复选项。 getAttribute()方法通过元素节点的属性名称获取属性的值。 语法： 1elementNode.getAttribute(name) 说明: elementNode：使用getElementById()、getElementsByTagName()等方法，获取到的元素节点。 name：要想查询的元素节点的属性名字 看看下面的代码，获取h1标签的属性值： 运行结果: 12h1标签的ID ：alinkh1标签的title ：getAttribute()获取标签的属值 setAttribute()方法setAttribute() 方法增加一个指定名称和值的新属性，或者把一个现有的属性设定为指定的值。 语法： 1elementNode.setAttribute(name,value) 说明： name: 要设置的属性名。 value: 要设置的属性值。 注意： 1.把指定的属性设置为指定的值。如果不存在具有指定名称的属性，该方法将创建一个新属性。2.类似于getAttribute()方法，setAttribute()方法只能通过元素节点对象调用的函数。 节点属性在文档对象模型 (DOM) 中，每个节点都是一个对象。DOM 节点有三个重要的属性 ： nodeName : 节点的名称 nodeValue ：节点的值 nodeType ：节点的类型 一、nodeName 属性: 节点的名称，是只读的。 元素节点的 nodeName 与标签名相同 属性节点的 nodeName 是属性的名称 文本节点的 nodeName 永远是 #text 文档节点的 nodeName 永远是 #document 二、nodeValue 属性：节点的值 元素节点的 nodeValue 是 undefined 或 null 文本节点的 nodeValue 是文本自身 属性节点的 nodeValue 是属性的值 三、nodeType 属性: 节点的类型，是只读的。以下常用的几种结点类型: 元素类型 节点类型 元素 1 属性 2 文本 3 注释 8 文档 9 访问子节点childNodes访问选定元素节点下的所有子节点的列表，返回的值可以看作是一个数组，他具有length属性。 语法： 1elementNode.childNodes 注意：如果选定的节点没有子节点，则该属性返回不包含节点的 NodeList。 我们来看看下面的代码: 运行结果: 1234IE: UL子节点个数:3 节点类型:1 其它浏览器: 12UL子节点个数:7节点类型:3 注意: IE全系列、firefox、chrome、opera、safari兼容问题 节点之间的空白符，在firefox、chrome、opera、safari浏览器是文本节点，所以IE是3，其它浏览器是7，如下图所示: 如果把代码改成这样: 1&lt;ul&gt;&lt;li&gt;javascript&lt;/li&gt;&lt;li&gt;jQuery&lt;/li&gt;&lt;li&gt;PHP&lt;/li&gt;&lt;/ul&gt; 运行结果:（IE和其它浏览器结果是一样的） 12UL子节点个数:3节点类型:1 访问子节点的第一和最后项一、firstChild 属性返回‘childNodes’数组的第一个子节点。如果选定的节点没有子节点，则该属性返回 NULL。 语法： 1node.firstChild 说明：与elementNode.childNodes[0]是同样的效果。 二、 lastChild 属性返回‘childNodes’数组的最后一个子节点。如果选定的节点没有子节点，则该属性返回 NULL。 语法： 1node.lastChild 说明：与elementNode.childNodes[elementNode.childNodes.length-1]是同样的效果。 注意: 上一节中，我们知道Internet Explorer 会忽略节点之间生成的空白文本节点，而其它浏览器不会。我们可以通过检测节点类型，过滤子节点。 (以后章节讲解) 访问父节点parentNode获取指定节点的父节点 语法： 1elementNode.parentNode 注意:父节点只能有一个。 看看下面的例子,获取 P 节点的父节点，代码如下: 1234567&lt;div id="text"&gt; &lt;p id="con"&gt; parentNode 获取指点节点的父节点&lt;/p&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt; var mynode= document.getElementById("con"); document.write(mynode.parentNode.nodeName);&lt;/script&gt; 运行结果: 12parentNode 获取指点节点的父节点DIV 访问祖节点: 1elementNode.parentNode.parentNode 看看下面的代码: 12345678910&lt;div id="text"&gt; &lt;p&gt; parentNode &lt;span id="con"&gt; 获取指点节点的父节点&lt;/span&gt; &lt;/p&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt; var mynode= document.getElementById("con"); document.write(mynode.parentNode.parentNode.nodeName);&lt;/script&gt; 运行结果: 12parentNode获取指点节点的父节点DIV 注意: 浏览器兼容问题，chrome、firefox等浏览器标签之间的空白也算是一个文本节点。 访问兄弟节点 nextSibling 属性可返回某个节点之后紧跟的节点（处于同一树层级中）。 语法：1nodeObject.nextSibling 说明：如果无此节点，则该属性返回 null。 previousSibling 属性可返回某个节点之前紧跟的节点（处于同一树层级中）。 语法：1nodeObject.previousSibling 说明：如果无此节点，则该属性返回 null。 注意: 两个属性获取的是节点。Internet Explorer 会忽略节点间生成的空白文本节点（例如，换行符号），而其它浏览器不会忽略。 解决问题方法: 判断节点nodeType是否为1, 如是为元素节点，跳过。 12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;nextSibling&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;ul id="u1"&gt; &lt;li&gt;javascript&lt;/li&gt; &lt;li&gt;jquery&lt;/li&gt; &lt;li&gt;html&lt;/li&gt; &lt;/ul&gt; &lt;ul id="u2"&gt; &lt;li&gt;css3&lt;/li&gt; &lt;li&gt;php&lt;/li&gt; &lt;li&gt;java&lt;/li&gt; &lt;/ul&gt; &lt;script type="text/javascript"&gt; function get_nextSibling(n) &#123; var x = n.nextSibling; while(x.nodeType!=1) &#123; x = x.nextSibling; &#125; return x; &#125; var x = document.getElementsByTagName("li")[0]; document.write(x.nodeName); document.write(" = "); document.write(x.innerHTML); var y = get_nextSibling(x); document.write("&lt;br&gt;nextsibling:"); document.write(y.nodeName); document.write(" = "); document.write(y.innerHTML); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 运行结果: 12LI = javascriptnextsibling: LI = jquery 插入节点appendChild()在指定节点的最后一个子节点列表之后添加一个新的子节点。 语法:1appendChild(newnode) 参数: newnode：指定追加的节点。 我们来看看，div标签内创建一个新的 P 标签，代码如下: 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;appendChild&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="test"&gt; &lt;p id="x1"&gt;HTML&lt;/p&gt; &lt;p&gt;JavaScript&lt;/p&gt; &lt;/div&gt; &lt;script type="text/javascript"&gt; var otest = document.getElementById("test"); var newnode = document.createElement("p"); newnode.innerHTML = "This is a new p"; // appendChild方法添加结点 otest.appendChild(newnode); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 运行结果: 123HTMLJavaScriptThis is a new p 插入节点insertBefore()insertBefore() 方法可在已有的子节点前插入一个新的子节点。 语法: 1insertBefore(newnode,node); 参数: newnode: 要插入的新节点。 node: 指定此节点前插入节点。 我们在来看看下面代码，在指定节点前插入节点。 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;insertBefore&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="div1"&gt;&lt;p id="x1"&gt;JavaScript&lt;/p&gt;&lt;p&gt;HTML&lt;/p&gt;&lt;/div&gt; &lt;script type="text/javascript"&gt; var otest = document.getElementById("div1"); var node = document.getElementById("x1"); var newnode = document.createElement("p"); newnode.innerHTML = "This is a new p"; otest.insertBefore(newnode,node); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 运行结果: 123This is a new pJavaScriptHTML 注意: otest.insertBefore(newnode,node); 也可以改为: otest.insertBefore(newnode,otest.childNodes[0]); 删除节点removeChild()removeChild() 方法从子节点列表中删除某个节点。如删除成功，此方法可返回被删除的节点，如失败，则返回 NULL。 语法:1nodeObject.removeChild(node) 参数:1node ：必需，指定需要删除的节点。 我们来看看下面代码，删除子点。 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;removeChild&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="div1"&gt;&lt;h1&gt;HTML&lt;/h1&gt;&lt;h2&gt;javascript&lt;/h2&gt;&lt;/div&gt; &lt;script type="text/javascript"&gt; var otest = document.getElementById("div1"); var x = otest.removeChild(otest.childNodes[1]); document.write("删除节点的内容："+x.innerHTML); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 运行结果:12HTML删除节点的内容: javascript 注意: 把删除的子节点赋值给 x，这个子节点不在DOM树中，但是还存在内存中，可通过 x 操作。 如果要完全删除对象，给 x 赋 null 值，代码如下: 123var otest = document.getElementById("div1");var x = otest.removeChild(otest.childNodes[1]);x = null; 替换元素节点replaceChild()replaceChild 实现子节点(对象)的替换。返回被替换对象的引用。 语法：1node.replaceChild (newnode,oldnew ) 参数： newnode : 必需，用于替换 oldnew 的对象。 oldnew : 必需，被 newnode 替换的对象。 我们来看看下面的代码: 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;replaceChild&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script type="text/javascript"&gt; function replaceMessage()&#123; var newnode = document.createElement("p"); var newnodeText = document.createTextNode("JavaScript"); newnode.appendChild(newnodeText); var oldNode = document.getElementById("oldnode"); oldNode.parentNode.replaceChild(newnode,oldNode); &#125; &lt;/script&gt; &lt;h1 id="oldnode"&gt;Java&lt;/h1&gt; &lt;a href="javascript:replaceMessage()"&gt;"Java" 替换 "JavaScript"&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 效果: 将文档中的 Java 改为 JavaScript。 注意: 当 oldnode 被替换时，所有与之相关的属性内容都将被移除。 newnode 必须先被建立。 创建元素节点createElementcreateElement()方法可创建元素节点。此方法可返回一个 Element 对象。 语法：1document.createElement(tagName) 参数: tagName：字符串值，这个字符串用来指明创建元素的类型。 注意：要与appendChild() 或 insertBefore()方法联合使用，将元素显示在页面中。 我们来创建一个按钮，代码如下：1234567&lt;script type="text/javascript"&gt; var body = document.body; var input = document.createElement("input"); input.type = "button"; input.value = "创建一个按钮"; body.appendChild(input); &lt;/script&gt; 效果：在HTML文档中，创建一个按钮。 我们也可以使用setAttribute来设置属性，代码如下： 123456789&lt;script type="text/javascript"&gt; var body= document.body; var btn = document.createElement("input"); btn.setAttribute("type", "text"); btn.setAttribute("name", "q"); btn.setAttribute("value", "使用setAttribute"); btn.setAttribute("onclick", "javascript:alert('This is a text!');"); body.appendChild(btn); &lt;/script&gt; 效果：在HTML文档中，创建一个文本框，使用setAttribute设置属性值。 当点击这个文本框时，会弹出对话框“This is a text!”。 创建文本节点createTextNodecreateTextNode() 方法创建新的文本节点，返回新创建的 Text 节点。 语法：1document.createTextNode(data) 参数： data : 字符串值，可规定此节点的文本。 我们来创建一个&lt;div&gt;元素并向其中添加一条消息，代码如下： 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;createTextNode&lt;/title&gt; &lt;style type="text/css"&gt; .message&#123; width: 200px; height: 100px; background-color: #CCC; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;script type="text/javascript"&gt; var element = document.createElement("div"); element.className = "message"; var textNode = document.createTextNode("Hello world!"); element.appendChild(textNode); document.body.appendChild(element);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 运行结果: 浏览器窗口可视区域大小获得浏览器窗口的尺寸（浏览器的视口，不包括工具栏和滚动条）的方法: 一、对于IE9+、Chrome、Firefox、Opera 以及 Safari： window.innerHeight - 浏览器窗口的内部高度 window.innerWidth - 浏览器窗口的内部宽度 二、对于 Internet Explorer 8、7、6、5： document.documentElement.clientHeight表示HTML文档所在窗口的当前高度。 document.documentElement.clientWidth表示HTML文档所在窗口的当前宽度。 或者 Document对象的body属性对应HTML文档的&lt;body&gt;标签 document.body.clientHeight document.body.clientWidth 在不同浏览器都实用的 JavaScript 方案： 1234var w= document.documentElement.clientWidth || document.body.clientWidth;var h= document.documentElement.clientHeight || document.body.clientHeight; 网页尺寸scrollHeightscrollHeight和scrollWidth，获取网页内容高度和宽度。 一、针对IE、Opera: scrollHeight 是网页内容实际高度，可以小于 clientHeight。 二、针对NS、FF: scrollHeight 是网页内容高度，不过最小值是 clientHeight。也就是说网页内容实际高度小于 clientHeight 时，scrollHeight 返回 clientHeight 。 三、浏览器兼容性 1234var w=document.documentElement.scrollWidth || document.body.scrollWidth;var h=document.documentElement.scrollHeight || document.body.scrollHeight; 注意:区分大小写 scrollHeight和scrollWidth还可获取Dom元素中内容实际占用的高度和宽度。 网页尺寸offsetHeightoffsetHeight和offsetWidth，获取网页内容高度和宽度(包括滚动条等边线，会随窗口的显示大小改变)。 一、值 offsetHeight = clientHeight + 滚动条 + 边框。 二、浏览器兼容性 1234var w= document.documentElement.offsetWidth || document.body.offsetWidth;var h= document.documentElement.offsetHeight || document.body.offsetHeight; 编程练习制作一个表格，显示班级的学生信息。 要求： 鼠标移到不同行上时背景色改为色值为 #f2f2f2，移开鼠标时则恢复为原背景色 #fff 点击添加按钮，能动态在最后添加一行 点击删除按钮，则删除当前行 任务第一步： 首先，我们创建删除函数，并在删除按钮上添加点击事件； 提示: 使用removeChild()。第二步： 编写一个函数，供添加按钮调用，动态在表格的最后一行添加子节点； 提示: 使用createElement()、innerHTML、appendChild()。第三步： 更改鼠标移动改变背景则可以通过给每行绑定鼠标移上事件和鼠标移除事件来改变所在行背景色。 提示: 获取表格的行，getElementsByTagName 。 使用for进行循环，为每行添加事件及背景颜色设置。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt; new document &lt;/title&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=gbk"/&gt; &lt;script type="text/javascript"&gt; window.onload = function()&#123; Highlight(); &#125; function addOne(obj)&#123; var tbody = document.getElementById('table').lastChild; var tr = document.createElement('tr'); var td = document.createElement("td"); td.innerHTML = "&lt;input type='text'/&gt;"; tr.appendChild(td); td = document.createElement("td"); td.innerHTML = "&lt;input type='text'/&gt;"; tr.appendChild(td); td = document.createElement("td"); td.innerHTML = "&lt;a href='javascript:;' onclick='deleteRow(this)'&gt;É¾³ý&lt;/a&gt;"; tr.appendChild(td); tbody.appendChild(tr); Highlight(); &#125; function deleteRow(obj)&#123; var tbody = document.getElementById('table').lastChild; var tr = obj.parentNode.parentNode; tbody.removeChild(tr); &#125; function Highlight()&#123; var tbody = document.getElementById('table').lastChild; trs = tbody.getElementsByTagName('tr'); for(var i =1;i&lt;trs.length;i++)&#123; trs[i].onmouseover = function()&#123; this.style.backgroundColor ="#f2f2f2"; &#125; trs[i].onmouseout = function()&#123; this.style.backgroundColor ="#fff"; &#125; &#125; &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;table border="1" width="50%" id="table"&gt; &lt;tr&gt; &lt;th&gt;学号&lt;/th&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;xh001&lt;/td&gt; &lt;td&gt;王小明&lt;/td&gt; &lt;td&gt;&lt;a href="javascript:;" onclick="deleteRow(this)"&gt;É¾³ý&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;xh002&lt;/td&gt; &lt;td&gt;刘小芳&lt;/td&gt; &lt;td&gt;&lt;a href="javascript:;" onclick="deleteRow(this)"&gt;É¾³ý&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;input type="button" value="Ìí¼ÓÒ»ÐÐ" onclick="addOne()" /&gt; &lt;/body&gt;&lt;/html&gt; #### 编程挑战 现在利用之前我们学过的JavaScript知识，实现选项卡切换的效果。 效果图: 文字素材: 房产： 275万购昌平邻铁三居 总价20万买一居 200万内购五环三居 140万安家东三环 北京首现零首付楼盘 53万购东5环50平 京楼盘直降5000 中信府 公园楼王现房 家居: 40平出租屋大改造 美少女的混搭小窝 经典清新简欧爱家 90平老房焕发新生 新中式的酷色温情 66平撞色活泼家居 瓷砖就像选好老婆 卫生间烟道的设计 二手房： 通州豪华3居260万 二环稀缺2居250w甩 西3环通透2居290万 130万2居限量抢购 黄城根小学学区仅260万 121平70万抛! 独家别墅280万 苏州桥2居优惠价248万 任务大家先思考和分析实现思路，然后在动手实现 一、HTML页面布局 提示: 选项卡标题使用ul..li 选项卡内容使用div 二、CSS样式制作 提示: 整个选项卡的样式设置 选项卡标题的样式设置 选项卡内容的样式设置 一开始只显示一个选项卡内容，其它选项卡内容隐藏。 三、JS实现选项卡切换 提示: 获取选项卡标题和选项卡内容 选项卡内容多个，需要循环遍历来操作，得知哪个选项卡和哪个选项内容匹配通过改变DOM的css类名称,当前点击的选项卡显示，其它隐藏。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang="en"&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;实践题 - 选项卡&lt;/title&gt; &lt;style type="text/css"&gt; *&#123;padding:0px;margin: 0px;font:12px normal "microsoft yahei";&#125; #tabs &#123;width:290px;padding:5px;height:150px;margin:20px;&#125; #tabs ul&#123;list-style:none;display: block;height:30px;line-height:30px;border-bottom:2px saddlebrown solid;&#125; #tabs ul li&#123;background:#fff;cursor:pointer;float:left;list-style:none;height:28px;line-height:28px;margin:0px 3px;border:1px solid #aaaaaa;border-bottom:none;display:inline-block;width:60px;text-align: center;&#125; #tabs ul li.on&#123;border-top:2px solid saddlebrown;border-bottom: 2px solid #fff;&#125; #tabs div&#123;height:120px;line-height: 25px;border:1px solid #336699;border-top:none;padding:5px;&#125; .hide&#123;display: none;&#125; &lt;/style&gt; &lt;script type="text/javascript"&gt; window.onload = function()&#123; var oTab = document.getElementById("tabs"); var oUl = oTab.getElementsByTagName("ul")[0]; var oLis = oUl.getElementsByTagName("li"); var oDivs= oTab.getElementsByTagName("div"); for(var i= 0,len = oLis.length;i&lt;len;i++)&#123; oLis[i].index = i; oLis[i].onclick = function() &#123; for(var n= 0;n&lt;len;n++)&#123; oLis[n].className = ""; oDivs[n].className = "hide"; &#125; this.className = "on"; oDivs[this.index].className = ""; &#125; &#125;; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="tabs"&gt; &lt;ul&gt; &lt;li class="on"&gt;房产&lt;/li&gt; &lt;li&gt;家居&lt;/li&gt; &lt;li&gt;二手房&lt;/li&gt; &lt;/ul&gt; &lt;div&gt; 275万购昌平邻铁三居 总价20万买一居&lt;br&gt; 200万内购五环三居 140万安家东三环&lt;br&gt; 北京首现零首付楼盘 53万购东5环50平&lt;br&gt; 京楼盘直降5000 中信府 公园楼王现房&lt;br&gt; &lt;/div&gt; &lt;div class="hide"&gt; 40平出租屋大改造 美少女的混搭小窝&lt;br&gt; 经典清新简欧爱家 90平老房焕发新生&lt;br&gt; 新中式的酷色温情 66平撞色活泼家居&lt;br&gt; 瓷砖就像选好老婆 卫生间烟道的设计&lt;br&gt; &lt;/div&gt; &lt;div class="hide"&gt; 通州豪华3居260万 二环稀缺2居250w甩&lt;br&gt; 西3环通透2居290万 130万2居限量抢购&lt;br&gt; 黄城根小学学区仅260万 121平70万抛!&lt;br&gt; 独家别墅280万 苏州桥2居优惠价248万&lt;br&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; /** * RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS. * LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/ (function() { // DON'T EDIT BELOW THIS LINE var d = document, s = d.createElement('script'); s.src = 'https://https-xrlrf-github-io.disqus.com/embed.js'; s.setAttribute('data-timestamp', +new Date()); (d.head || d.body).appendChild(s); })(); Please enable JavaScript to view the comments powered by Disqus. window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-107582762-1');]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[相对定位与绝对定位的区别]]></title>
    <url>%2F2017%2F10%2F10%2F%E7%9B%B8%E5%AF%B9%E5%AE%9A%E4%BD%8D%E4%B8%8E%E7%BB%9D%E5%AF%B9%E5%AE%9A%E4%BD%8D%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[你对CSS相对定位和绝对定位区别是否了解，这里和大家分享一下，CSS绝对定位使元素的位置与文档流无关，因此不占据空间。这一点与CSS相对定位不同，CSS相对定位实际上被看作普通流定位模型的一部分，因为元素的位置相对于它在普通流中的位置。 CSS相对定位和绝对定位区别CSS相对定位 CSS相对定位是一个非常容易掌握的概念。如果对一个元素进行CSS相对定位，它将出现在它所在的位置上。然后，可以通过设置垂直或水平位置，让这个元素“相对于”它的起点进行移动。 如果将top设置为20px，那么框将在原位置顶部下面20像素的地方。如果left设置为30像素，那么会在元素左边创建30像素的空间，也就是将元素向右移动。 12345#box_relative&#123; position:relative; left:30px; top:20px; &#125; 如下图所示： CSS相对定位 注意，在使用CSS相对定位时，无论是否进行移动，元素仍然占据原来的空间。因此，移动元素会导致它覆盖其它框。 设置为CSS绝对定位的元素框从文档流完全删除，并相对于其包含块定位，包含块可能是文档中的另一个元素或者是初始包含块。元素原先在正常文档流中所占的空间会关闭，就好像该元素原来不存在一样。元素定位后生成一个块级框，而不论原来它在正常流中生成何种类型的框。 CSS绝对定位 CSS绝对定位使元素的位置与文档流无关，因此不占据空间。这一点与CSS相对定位不同，CSS相对定位实际上被看作普通流定位模型的一部分，因为元素的位置相对于它在普通流中的位置。 普通流中其它元素的布局就像CSS绝对定位的元素不存在一样： 12345#box_relative&#123; position:absolute; left:30px; top:20px; &#125; 如下图所示： CSS绝对定位 CSS绝对定位的元素的位置相对于最近的已定位祖先元素，如果元素没有已定位的祖先元素，那么它的位置相对于最初的包含块。 对于定位的主要问题是要记住每种定位的意义。所以，现在让我们复习一下学过的知识吧：CSS相对定位是“相对于”元素在文档中的初始位置，而CSS绝对定位是“相对于”最近的已定位祖先元素，如果不存在已定位的祖先元素，那么“相对于”最初的包含块。 提示：因为CSS绝对定位的框与文档流无关，所以它们可以覆盖页面上的其它元素。可以通过设置z-index属性来控制这些框的堆放次序。 /** * RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS. * LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/ (function() { // DON'T EDIT BELOW THIS LINE var d = document, s = d.createElement('script'); s.src = 'https://https-xrlrf-github-io.disqus.com/embed.js'; s.setAttribute('data-timestamp', +new Date()); (d.head || d.body).appendChild(s); })(); Please enable JavaScript to view the comments powered by Disqus. window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-107582762-1');]]></content>
      <categories>
        <category>前端学习</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F10%2F10%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment /** * RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS. * LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/ (function() { // DON'T EDIT BELOW THIS LINE var d = document, s = d.createElement('script'); s.src = 'https://https-xrlrf-github-io.disqus.com/embed.js'; s.setAttribute('data-timestamp', +new Date()); (d.head || d.body).appendChild(s); })(); Please enable JavaScript to view the comments powered by Disqus. window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-107582762-1');]]></content>
  </entry>
  <entry>
    <title><![CDATA[前端基本布局]]></title>
    <url>%2F2017%2F10%2F10%2F%E5%89%8D%E7%AB%AF%E5%9F%BA%E6%9C%AC%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[两列布局12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;两列布局&lt;/title&gt; &lt;style type="text/css"&gt; *&#123; margin: 0px; padding: 0px; border: 0px; &#125; body,html&#123; width:100%; &#125; #zuo&#123; width: 400px; height: 600px; background-color: #960; float: left; &#125; #you&#123; height: 600px; background-color: #0FC; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="zuo"&gt;&lt;/div&gt; &lt;div id="you"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 效果图为： 两列自适应居中123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;两列自适应居中&lt;/title&gt; &lt;style type="text/css"&gt; *&#123; margin: 0px; padding: 0px; border: 0px; &#125; body,html&#123; width:100%; &#125; #zuo&#123; width: 30%; height: 600px; background-color: #960; float: left; &#125; #you&#123; width: 70%; height: 600px; background-color: #0FC; float: left; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="zuo"&gt;&lt;/div&gt; &lt;div id="you"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 效果图为： 三列布局中间自适应123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;三列布局中间自适应&lt;/title&gt; &lt;style type="text/css"&gt; *&#123; margin: 0px; padding: 0px; border: 0px; &#125; html,body&#123; height: 100%; width: 100%; &#125; #zuo&#123; width: 200px; height: 100%; background-color: #960; position: absolute; top: 0px; left: 0px; &#125; #you&#123; width: 200px; height: 100%; background-color: #960; position: absolute; top: 0px; right: 0px; &#125; #ong&#123; height: 100%; background-color: #0FC; margin-left: 200px; margin-right: 200px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="zuo"&gt;&lt;/div&gt; &lt;div id="ong"&gt;&lt;/div&gt; &lt;div id="you"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 效果图为： 复杂页面排版1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;复杂页面排版&lt;/title&gt; &lt;style type="text/css"&gt; *&#123; margin: 0px; padding: 0px; border: 0px; &#125; #box&#123; height: 1330px; width: 950px; margin: auto; &#125; #hen&#123; height: 245px; width: 950px; background-color: #963; &#125; #zuo&#123; height: 915px; width: 386px; margin-top: 10px; margin-bottom: 10px; background-color: #C30; float: left; &#125; #xia1&#123; height: 540px; width: 272px; margin-top: 10px; margin-left: 10px; background-color: #099; float: left; &#125; #xia2&#123; height: 540px; width: 272px; margin-top: 10px; margin-left: 10px; background-color: #099; float: left; &#125; #xia3&#123; height: 365px; width: 554px; margin-top: 10px; background-color: #C66; float: right; &#125; #dib&#123; height: 150px; width: 950px; margin-top: 10px; background-color: #639; clear: both &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="box"&gt; &lt;div id="hen"&gt;&lt;/div&gt; &lt;div id="zuo"&gt;&lt;/div&gt; &lt;div id="xia1"&gt;&lt;/div&gt; &lt;div id="xia2"&gt;&lt;/div&gt; &lt;div id="xia3"&gt;&lt;/div&gt; &lt;div id="dib"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 效果图为： /** * RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS. * LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/ (function() { // DON'T EDIT BELOW THIS LINE var d = document, s = d.createElement('script'); s.src = 'https://https-xrlrf-github-io.disqus.com/embed.js'; s.setAttribute('data-timestamp', +new Date()); (d.head || d.body).appendChild(s); })(); Please enable JavaScript to view the comments powered by Disqus. window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-107582762-1');]]></content>
  </entry>
  <entry>
    <title><![CDATA[JavaScript入门篇]]></title>
    <url>%2F2017%2F10%2F09%2FJavaScript%E5%85%A5%E9%97%A8%E7%AF%87%2F</url>
    <content type="text"><![CDATA[javascript介绍JavaScript代码写在`&lt;script&gt;&lt;/script&gt;`之间。`&lt;script type=&quot;text/javascript&quot;&gt;表示在&lt;script&gt;&lt;/script&gt;`之间的是文本类型(text),javascript是为了告诉浏览器里面的文本是属于JavaScript语言。 JS文件放在哪？ 放在&lt;body&gt;&lt;/body&gt;内部引用 放在&lt;head&gt;&lt;/head&gt;内部引用 单独写一个js文件存放，需要在哪个地方引用就在哪个地方用`引用 我们可以把HTML文件和JS代码分开,并单独创建一个JavaScript文件(简称JS文件),其文件后缀通常为.js，然后将JS代码直接写在JS文件中。 注意:在JS文件中，不需要&lt;script&gt;标签,直接编写JavaScript代码就可以了。 JS文件不能直接运行，需嵌入到HTML文件中执行，我们需在HTML中添加如下代码，就可将JS文件嵌入HTML文件中。 1&lt;script src="script.js"&gt;&lt;/script&gt; 放在&lt;head&gt;部分 最常用的方式是在页面中head部分放置&lt;script&gt;元素，浏览器解析head部分就会执行这个代码，然后才解析页面的其余部分。 放在&lt;body&gt;部分 JavaScript代码在网页读取到该语句的时候就会执行。 注意: javascript作为一种脚本语言可以放在html页面中任何位置，但是浏览器解释html时是按先后顺序的，所以前面的script就先被执行。比如进行页面显示初始化的js必须放在head里面，因为初始化都要求提前进行（如给页面body设置css等）；而如果是通过事件调用执行的function那么对位置没什么要求的。 变量变量名可以任意取名，但要遵循命名规则: 1.变量必须使用字母、下划线(_)或者美元符($)开始。 2.然后可以使用任意多个英文字母、数字、下划线(_)或者美元符($)组成。 3.不能使用JavaScript关键词与JavaScript保留字。 变量要先声明再赋值，如下： 123var mychar;mychar="javascript";var mynum = 6; 变量可以重复赋值，如下： 123var mychar;mychar="javascript";mychar="hello"; 注意: 在JS中区分大小写，如变量mychar与myChar是不一样的，表示是两个变量。 变量虽然也可以不声明，直接使用，但不规范，需要先声明，后使用。 if else判断语句语法: 1234if(条件)&#123; 条件成立时执行的代码 &#125;else&#123; 条件不成立时执行的代码 &#125; 假设我们通过年龄来判断是否为成年人，如年龄大于等于18岁，是成年人，否则不是成年人。代码表示如下: 1234567&lt;script type="text/javascript"&gt; var myage = 18; if(myage&gt;=18) //myage&gt;=18是判断条件 &#123; document.write("你是成年人。");&#125; else //否则年龄小于18 &#123; document.write("未满18岁，你不是成年人。");&#125;&lt;/script&gt; 函数如何定义一个函数呢？基本语法如下: 1234function 函数名()&#123; 函数代码;&#125; 说明: function定义函数的关键字。 “函数名”你为函数取的名字。 “函数代码”替换为完成特定功能的代码。 我们来编写一个实现两数相加的简单函数,并给函数起个有意义的名字：“add2”，代码如下： 1234function add2()&#123; var sum = 3 + 2; alert(sum);&#125; 函数调用: 函数定义好后，是不能自动执行的，所以需调用它,只需直接在需要的位置写函数就ok了,代码如下: 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;函数&lt;/title&gt; &lt;script type="text/javascript"&gt; function add2()&#123; sum = 5 + 6; alert(sum); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;form&gt; &lt;input type="button" value="点击" onclick="add2()"&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 输出内容（document.write）document.write() 可用于直接向 HTML 输出流写内容。简单的说就是直接在网页中输出内容。 第一种:输出内容用””括起，直接输出””号内的内容。123&lt;script type="text/javascript"&gt; document.write("I love JavaScript！"); //内容用""括起来，""里的内容直接输出。&lt;/script&gt; 第二种:通过变量，输出内容1234&lt;script type="text/javascript"&gt; var mystr="hello world!"; document.write(mystr); //直接写变量名，输出变量存储的内容。&lt;/script&gt; 第三种:输出多项内容，内容之间用+号连接。1234&lt;script type="text/javascript"&gt; var mystr="hello"; document.write(mystr+"I love JavaScript"); //多项内容之间用+号连接&lt;/script&gt; 第四种:输出HTML标签，并起作用，标签使用””括起来。 12345&lt;script type="text/javascript"&gt; var mystr="hello";document.write(mystr+"&lt;br&gt;");//输出hello后，输出一个换行符 document.write("JavaScript");&lt;/script&gt; 警告（alert 消息对话框）我们在访问网站的时候，有时会突然弹出一个小窗口，上面写着一段提示信息文字。如果你不点击“确定”，就不能对网页做任何操作，这个小窗口就是使用alert实现的。 语法: alert(字符串或变量); 看下面的代码: 12345&lt;script type="text/javascript"&gt; var mynum = 30; alert("hello!"); alert(mynum);&lt;/script&gt; 确认（confirm 消息对话框）confirm 消息对话框通常用于允许用户做选择的动作，如：“你对吗？”等。弹出对话框(包括一个确定按钮和一个取消按钮)。 语法: confirm(str); 参数说明: str：在消息对话框中要显示的文本 返回值: Boolean值 当用户点击&quot;确定&quot;按钮时，返回true 当用户点击&quot;取消&quot;按钮时，返回false 注: 通过返回值可以判断用户点击了什么按钮 看下面的代码: 1234567&lt;script type="text/javascript"&gt; var mymessage=confirm("你喜欢JavaScript吗?"); if(mymessage==true) &#123; document.write("很好,加油!"); &#125; else &#123; document.write("JS功能强大，要学习噢!"); &#125;&lt;/script&gt; 提问（prompt 消息对话框）prompt弹出消息对话框,通常用于询问一些需要与用户交互的信息。弹出消息对话框（包含一个确定按钮、取消按钮与一个文本输入框）。 语法: prompt(str1, str2); 参数说明： str1: 要显示在消息对话框中的文本，不可修改 str2：文本框中的内容，可以修改 返回值: 1. 点击确定按钮，文本框中的内容将作为函数返回值 2. 点击取消按钮，将返回null 看看下面代码: 12345var myname=prompt("请输入你的姓名:");if(myname!=null) &#123; alert("你好"+myname); &#125;else &#123; alert("你好 my friend."); &#125; 打开新窗口（window.open）open() 方法可以查找一个已经存在或者新建的浏览器窗口。 语法： window.open([URL], [窗口名称], [参数字符串]) 参数说明: URL：可选参数，在窗口中要显示网页的网址或路径。如果省略这个参数，或者它的值是空字符串，那么窗口就不显示任何文档。 窗口名称：可选参数，被打开窗口的名称。 1. 该名称由字母、数字和下划线字符组成。 2. &quot;_top&quot;、&quot;_blank&quot;、&quot;_self&quot;具有特殊意义的名称。 _blank：在新窗口显示目标网页 _self：在当前窗口显示目标网页 _top：框架网页中在上部窗口中显示目标网页 3. 相同 name 的窗口只能创建一个，要想创建多个窗口则 name 不能相同。 4. name 不能包含有空格。 参数字符串：可选参数，设置窗口参数，各参数用逗号隔开。 参数表： 参数 值 说明 top Number 窗口顶部离开屏幕顶部的像素数 left Number 窗口左端离开屏幕左端的像素数 width Number 窗口的宽度 height Number 窗口的高度 menubar yes,no 窗口有没有菜单 toolbar yes,no 窗口有没有工具条 scrollbars yes,no 窗口有没有滚动条 status yes,no 窗口有没有状态栏 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;prompt&lt;/title&gt; &lt;script type="text/javascript"&gt; function Wopen()&#123; window.open('http://www.imooc.com','_blank','width=600,height=400,menubar=no,toolbar=no,status=no,scrollbars=yes,top=10,left=0') &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;form&gt; &lt;input type="button" value="点击我，打开新窗口" onclick="Wopen()"&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 关闭窗口（window.close）close()关闭窗口 用法： window.close(); //关闭本窗口 或 &lt;窗口对象&gt;.close(); //关闭指定的窗口 例如:关闭新建的窗口。 1234&lt;script type="text/javascript"&gt; var mywin=window.open('http://www.imooc.com'); //将新打的窗口对象，存储在变量mywin中 mywin.close();&lt;/script&gt; 认识DOM文档对象模型DOM（Document Object Model）定义访问和处理HTML文档的标准方法。DOM 将HTML文档呈现为带有元素、属性和文本的树结构（节点树）。 先来看看下面代码: 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;DOM&lt;/title&gt;&lt;body&gt; &lt;h2&gt;&lt;a href="http://www.imooc.com"&gt;javascript DOM&lt;/a&gt;&lt;/h2&gt; &lt;p&gt;对HTML元素进行操作，可添加，改变或移除CSS样式等&lt;/p&gt; &lt;ul&gt; &lt;li&gt;JavaScript&lt;/li&gt; &lt;li&gt;DOM&lt;/li&gt; &lt;li&gt;CSS&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 将HTML代码分解为DOM节点层次图: HTML文档可以说由节点构成的集合，三种常见的DOM节点: 元素节点：上图中&lt;html&gt;、&lt;body&gt;、&lt;p&gt;等都是元素节点，即标签。 文本节点:向用户展示的内容，如&lt;li&gt;...&lt;/li&gt;中的JavaScript、DOM、CSS等文本。 属性节点:元素属性，如&lt;a&gt;标签的链接属性href=”http://www.imooc.com&quot;。 看下面代码: 1&lt;a href="http://www.imooc.com"&gt;JavaScript DOM&lt;/a&gt; 通过ID获取元素学过HTML/CSS样式，都知道，网页由标签将信息组织起来，而标签的id属性值是唯一的，就像是每人有一个身份证号一样，只要通过身份证号就可以找到相对应的人。那么在网页中，我们通过id先找到标签，然后进行操作。 语法: 1document.getElementById(“id”) 看看下面代码: 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;获取元素&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p id="con"&gt;JavaScript&lt;/p&gt; &lt;script type="text/javascript"&gt; var mychar = document.getElementById("con"); document.write("结果："+mychar); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 结果:null或[object HTMLParagraphElement] 注:获取的元素是一个对象，如想对元素进行操作，我们要通过它的属性或方法。 innerHTML 属性innerHTML 属性用于获取或替换 HTML 元素的内容。 语法: Object.innerHTML 注意: 1.Object是获取的元素对象，如通过document.getElementById(&quot;ID&quot;)获取的元素。 2.注意书写，innerHTML区分大小写。 我们通过id=”con”获取&lt;p&gt; 元素，并将元素的内容输出和改变元素内容，代码如下: 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;innerHTML&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p id="con"&gt;Hello World!&lt;/p&gt; &lt;script type="text/javascript"&gt; var mycon = document.getElementById("con"); document.write("p标签原始内容："+mycon.innerHTML+"&lt;br&gt;") // 输入元素内容 mycon.innerHTML="New text!"; document.write("p标签修改后内容："+mycon.innerHTML); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 改变 HTML 样式HTML DOM 允许 JavaScript 改变 HTML 元素的样式。如何改变 HTML 元素的样式呢？ 语法: Object.style.property=new style; 注意:Object是获取的元素对象，如通过document.getElementById(“id”)获取的元素。 看看下面的代码: 改变 &lt;p&gt; 元素的样式，将颜色改为红色，字号改为20,背景颜色改为蓝： 1234567&lt;p id="pcon"&gt;Hello World!&lt;/p&gt;&lt;script&gt; var mychar = document.getElementById("pcon"); mychar.style.color="red"; mychar.style.fontSize="20"; mychar.style.backgroundColor ="blue";&lt;/script&gt; 显示和隐藏（display属性）网页中经常会看到显示和隐藏的效果，可通过display属性来设置。 语法： Object.style.display = value 注意:Object是获取的元素对象，如通过document.getElementById(“id”)获取的元素。 value取值: 值 描述 none 此元素不会被显示，即隐藏 block 此元素将显示为块级元素 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;display&lt;/title&gt; &lt;script type="text/javascript"&gt; function hidetext()&#123; var mychar = document.getElementById("con"); mychar.style.display="none"; &#125; function showtext()&#123; var mychar = document.getElementById("con"); mychar.style.display="block"; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;JavaScript&lt;/h1&gt; &lt;p id="con"&gt;作为一个web开发师来说，如果你想提供漂亮的网页，令用户满意的上网体验，JavaScript是必不可少的工具&lt;/p&gt; &lt;form&gt; &lt;input type="button" onclick="hidetext()" value="隐藏内容"&gt; &lt;input type="button" onclick="showtext()" value="显示内容"&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 控制类名（className 属性）className 属性设置或返回元素的class 属性。 语法： object.className = classname 作用: 1.获取元素的class 属性 2. 为网页内的某个元素指定一个css样式来更改该元素的外观 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;className属性&lt;/title&gt; &lt;style type="text/css"&gt; input&#123; font-size: 10px; &#125; .one&#123; width: 200px; background-color: #CCC; &#125; .two&#123; font-size: 18px; color: #F00; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;p id="con" class="one"&gt;JavaScript&lt;/p&gt; &lt;form&gt; &lt;input type="button" value="点击更改" onclick="modifyclass()"&gt; &lt;/form&gt; &lt;script type="text/javascript"&gt; var mychar = document.getElementById("con"); document.write("p元素Class值为："+mychar.className+"&lt;br&gt;"); function modifyclass()&#123; mychar.className = "two"; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; /** * RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS. * LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/ (function() { // DON'T EDIT BELOW THIS LINE var d = document, s = d.createElement('script'); s.src = 'https://https-xrlrf-github-io.disqus.com/embed.js'; s.setAttribute('data-timestamp', +new Date()); (d.head || d.body).appendChild(s); })(); Please enable JavaScript to view the comments powered by Disqus. window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-107582762-1');]]></content>
      <categories>
        <category>JavaScript学习</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python网络爬虫与信息提取(三)：网络爬虫之实战]]></title>
    <url>%2F2017%2F10%2F09%2FPython%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB%E4%B8%8E%E4%BF%A1%E6%81%AF%E6%8F%90%E5%8F%96-%E4%B8%89-%EF%BC%9A%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB%E4%B9%8B%E5%AE%9E%E6%88%98%2F</url>
    <content type="text"><![CDATA[Re(正则表达式)库入门 regular expression = regex = RE 是一种通用的字符串表达框架,用来简洁表达一组字符串的表达式,也可用来判断某字符串的特征归属 正则表达式的语法 常用操作符 实例 Re库的基本使用 正则表达式的表示类型为raw string类型(原生字符串类型),表示为r’text’ Re库主要功能函数 功能函数 re.search(pattern,string,flags=0) re.match(pattern,string,flags=0) 因为match为从开始位置开始匹配,使用时要加if进行判别返回结果是否为空,否则会报错 re.findall(pattern,string,flags=0) re.split(pattern,string,maxsplit=0,flags=0) maxsplit为最大分割数,剩余部分作为最后一个元素输出 re.finditer(pattern,string,flags=0) re.sub(pattern,repl,string,count=0,flags=0) repl是用来替换的字符串,count为替换次数 Re库的另一种等价用法 Re库的函数式用法为一次性操作,还有一种为面向对象用法,可在编译后多次操作 1regex = re.compile(pattern,flags=0) 通过compile生成的regex对象才能被叫做正则表达式 Match对象的属性 Match对象的方法 例子 Re库的贪婪匹配和最小匹配 Re库默认采取贪婪匹配,即输出匹配最长的子串 实例二:淘宝商品比价定向爬虫(requests-re) 步骤1:提交商品搜索请求,循环获取页面 步骤2:对于每个页面,提取商品名称和价格信息 步骤3:将信息输出显示 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import requestsimport redef getHTMLText(url): try: r = requests.get(url, timeout=30) r.raise_for_status() r.encoding = r.apparent_encoding return r.text except: return ""def parsePage(ilt, html): try: plt = re.findall(r'\"view_price\"\:\"[\d\.]*\"',html) tlt = re.findall(r'\"raw_title\"\:\".*?\"',html) for i in range(len(plt)): price = eval(plt[i].split(':')[1]) title = eval(tlt[i].split(':')[1]) ilt.append([price , title]) except: print("")def printGoodsList(ilt): tplt = "&#123;:4&#125;\t&#123;:8&#125;\t&#123;:16&#125;" print(tplt.format("序号", "价格", "商品名称")) count = 0 for g in ilt: count = count + 1 print(tplt.format(count, g[0], g[1]))def main(): goods = '书包' depth = 3 start_url = 'https://s.taobao.com/search?q=' + goods infoList = [] for i in range(depth): try: url = start_url + '&amp;s=' + str(44*i) html = getHTMLText(url) parsePage(infoList, html) except: continue printGoodsList(infoList)main() 实例三:股票数据定向爬虫 步骤1:从东方财富网获取股票列表 步骤2:根据股票列表逐个到百度股票获取个股信息 步骤3:将结果存储到文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#CrawBaiduStocksB.pyimport requestsfrom bs4 import BeautifulSoupimport tracebackimport redef getHTMLText(url, code="utf-8"): try: r = requests.get(url) r.raise_for_status() r.encoding = code return r.text except: return ""def getStockList(lst, stockURL): html = getHTMLText(stockURL, "GB2312") soup = BeautifulSoup(html, 'html.parser') a = soup.find_all('a') for i in a: try: href = i.attrs['href'] lst.append(re.findall(r"[s][hz]\d&#123;6&#125;", href)[0]) except: continuedef getStockInfo(lst, stockURL, fpath): count = 0 for stock in lst: url = stockURL + stock + ".html" html = getHTMLText(url) try: if html=="": continue infoDict = &#123;&#125; soup = BeautifulSoup(html, 'html.parser') stockInfo = soup.find('div',attrs=&#123;'class':'stock-bets'&#125;) name = stockInfo.find_all(attrs=&#123;'class':'bets-name'&#125;)[0] infoDict.update(&#123;'股票名称': name.text.split()[0]&#125;) keyList = stockInfo.find_all('dt') valueList = stockInfo.find_all('dd') for i in range(len(keyList)): key = keyList[i].text val = valueList[i].text infoDict[key] = val with open(fpath, 'a', encoding='utf-8') as f: f.write( str(infoDict) + '\n' ) count = count + 1 print("\r当前进度: &#123;:.2f&#125;%".format(count*100/len(lst)),end="") except: count = count + 1 print("\r当前进度: &#123;:.2f&#125;%".format(count*100/len(lst)),end="") continuedef main(): stock_list_url = 'http://quote.eastmoney.com/stocklist.html' stock_info_url = 'https://gupiao.baidu.com/stock/' output_file = 'D:/BaiduStockInfo.txt' slist=[] getStockList(slist, stock_list_url) getStockInfo(slist, stock_info_url, output_file)main() /** * RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS. * LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/ (function() { // DON'T EDIT BELOW THIS LINE var d = document, s = d.createElement('script'); s.src = 'https://https-xrlrf-github-io.disqus.com/embed.js'; s.setAttribute('data-timestamp', +new Date()); (d.head || d.body).appendChild(s); })(); Please enable JavaScript to view the comments powered by Disqus. window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-107582762-1');]]></content>
      <categories>
        <category>Python学习</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python网络爬虫与信息提取(二)：网络爬虫之提取]]></title>
    <url>%2F2017%2F10%2F09%2FPython%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB%E4%B8%8E%E4%BF%A1%E6%81%AF%E6%8F%90%E5%8F%96-%E4%BA%8C-%EF%BC%9A%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB%E4%B9%8B%E6%8F%90%E5%8F%96%2F</url>
    <content type="text"><![CDATA[Beautiful Soup库可对HTML/XML格式进行解析并提取相关信息 安装: pip install beautifulsoup4 小测： 1234567&gt;&gt;&gt; import requests&gt;&gt;&gt; r = requests.get("http://python123.io/ws/demo.html")&gt;&gt;&gt; r.text&gt;&gt;&gt; demo = r.text&gt;&gt;&gt; from bs4 import BeautifulSoup&gt;&gt;&gt; soup = BeautifulSoup(demo,"html.parser")&gt;&gt;&gt; print(soup.prettify()) Beautiful Soup库是解析/遍历/维护”标签熟”的功能库,引用方式: 12from bs4 import BeautifulSoupimport bs4 Beautiful Soup库的4种解析器: Beautiful Soup类的基本元素: bs类基本元素 Tag标签任何存在于HTML语法中的标签都可用**soup.访问获得,存在多个取第一个 Tag的name每个有自己的名字,通过.name获取,字符串类型 Tag的attrs Tag的NavigableString Tag的Comment 由find_all()扩展的七个方法: 实例一:中国大学排名爬虫 123456789101112131415161718192021222324252627282930313233343536#!/usr/bin/env python# coding=utf-8import requestsfrom bs4 import BeautifulSoupimport bs4def getHTMLText(url): try: r = requests.get(url,timeout=30) r.raise_for_status() r.encoding=r.apparent_encoding return r.text except: return "error"def fillUnivList(ulist,html): soup=BeautifulSoup(html,"html.parser") for tr in soup.find('tbody').children: if isinstance(tr,bs4.element.Tag): tds = tr('td') ulist.append([tds[0].string,tds[1].string,tds[2].string])def printUnivList(ulist,num): tplt="&#123;0:^10&#125;\t&#123;1:&#123;3&#125;^10&#125;\t&#123;2:^10&#125;" print(tplt.format("排名","学校名称","总分",chr(12288))) for i in range(num): u=ulist[i] print(tplt.format(u[0],u[1],u[2],chr(12288)))def main(): uinfo=[] url = "http://www.zuihaodaxue.cn/zuihaodaxuepaiming2016.html" html = getHTMLText(url) fillUnivList(uinfo,html) printUnivList(uinfo,20)main() /** * RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS. * LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/ (function() { // DON'T EDIT BELOW THIS LINE var d = document, s = d.createElement('script'); s.src = 'https://https-xrlrf-github-io.disqus.com/embed.js'; s.setAttribute('data-timestamp', +new Date()); (d.head || d.body).appendChild(s); })(); Please enable JavaScript to view the comments powered by Disqus. window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-107582762-1');]]></content>
      <categories>
        <category>Python学习</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python网络爬虫与信息提取(一)]]></title>
    <url>%2F2017%2F10%2F09%2FPython%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB%E4%B8%8E%E4%BF%A1%E6%81%AF%E6%8F%90%E5%8F%96-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[Requests库的七个主要方法: get方法 r = requests.get(url):右边构造一个向服务器请求资源的Requests对象,左边返回一个包含服务器资源的Response对象给r 完整参数:requests.get(url,params=None,**kwargs),实则由request方法封装 Response对象的五个属性: 爬取网页的通用代码框架 Requests库爬取网页会遇到异常: 6种常见异常： 使用r.raise_for_status()方法构建通用代码框架: 12345678910#!/usr/bin/env python# coding=utf-8def getHTMLText(url)try: r = request.get(url,timeout = 30) r.raise_for_status() r.encoding = r.apparent_encoding return r.textexcept: return "产生异常" HTTP协议对资源的操作: Requests库主要方法:requests.request(method,url,kwargs)** method(请求方式)包括: GET/HEAD/POST/PUT/PATCH/delete/OPTIONS **kwargs(控制访问参数)包括: params(添加键值到url后)/data(字典/字节序列等作为Request的内容)/json/headers(HTTP定制头)/cookies(Request中的cookie)/auth(元祖,支持HTTP认证)/files(传输文件)/timeout/proxies(设定访问代理服务器)/allow_redirects(重定向开关)/stream(获取内容立即下载开关)/verify(认证SSL证书开关)/cert(本地SSL证书路径) Requests库爬取实例 京东商品页面的爬取 123456789import requestsurl = "http://item.jd.com/2967929.html"try: r=requests.get(url) r.raise_for_status() r.encoding=r.apparent_encoding print(r.text[:1000])except: print("爬取失败") 亚马逊商品页面的爬取由于亚马逊有自身的头部审查,故我们模拟浏览器访问: 12345678910import requestsurl = "http://www.amazon.cn/gp/product/B01M8L5Z3Y"try: kv = &#123;'user-agent':'Mozilla/5.0'&#125; r= requests.get(url,headers = kv) r.raise_for_status() r.encoding=r.apparent_encoding print(r.text[1000:2000])except: print("爬取失败") 百度/360搜索关键词提交首先我们需要知道搜索关键词的提交接口:百度:http://www.baidu.com/s?wd=keyword360:http://www.so.com/s?q=keyword接下来我们可以利用params参数将关键词加入,代码如下: 12345678910import requestskeyword = "Python"try: kv = &#123;'wd':keyword&#125; r= requests.get("http://www.baidu.com/s",params = kv) print(r.request.url) r.raise_for_status() print(len(r.text))except: print("爬取失败") 网络图片的爬取和存储 123456789101112131415161718192021#!/usr/bin/env python# coding=utf-8import requestsimport osurl = "http://image.nationalgeographic.com.cn/2017/0311/20170311024522382.jpg"root = "/home/xiaorui/文档/Python/"path = root +url.split('/')[-1]try: if not os.path.exists(root): os.mkdir(root) if not os.path.exists(path): r=requests.get(url) with open(path,'wb') as f: f.write(r.content) f.close() print("文件保存成功") else: print("文件已存在")except: print("爬取失败") IP地址归属地的查询 1234567891011#!/usr/bin/env python# coding=utf-8import requestsurl = "http://m.ip138.com/ip.asp?ip="try: r=requests.get(url+'202.204.80.112') r.raise_for_status() r.encoding=r.apparent_encoding print(r.text[-500:])except: print("爬取失败") /** * RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS. * LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/ (function() { // DON'T EDIT BELOW THIS LINE var d = document, s = d.createElement('script'); s.src = 'https://https-xrlrf-github-io.disqus.com/embed.js'; s.setAttribute('data-timestamp', +new Date()); (d.head || d.body).appendChild(s); })(); Please enable JavaScript to view the comments powered by Disqus. window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-107582762-1');]]></content>
      <categories>
        <category>Python学习</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown新手指南手册]]></title>
    <url>%2F2017%2F10%2F09%2Fmarkdown%E6%96%B0%E6%89%8B%E6%8C%87%E5%8D%97%E6%89%8B%E5%86%8C%2F</url>
    <content type="text"><![CDATA[标题123456# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 列表无序列表123- 文本1- 文本2- 文本3 有序列表1231. 文本12. 文本23. 文本3 链接1[显示文本](链接地址) 图片1![](图片链接地址) 引用1&gt; 需要引用的文本 粗体1**文本** 斜体1*文本* 代码引用用两个、、、包围需要引用的代码即可 表格12345|Tables |Are |Cool ||-----------------|:-----------|----||col 3 is |right-aligned | $1600 ||col 2 is |centered | $12 ||zebra stripes | are neat | $1 | 显示效果： Tables Are Cool col 3 is right-aligned $1600 col 2 is centered $12 zebra stripes are neat $1 /** * RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS. * LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/ (function() { // DON'T EDIT BELOW THIS LINE var d = document, s = d.createElement('script'); s.src = 'https://https-xrlrf-github-io.disqus.com/embed.js'; s.setAttribute('data-timestamp', +new Date()); (d.head || d.body).appendChild(s); })(); Please enable JavaScript to view the comments powered by Disqus. window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-107582762-1');]]></content>
      <categories>
        <category>Linux学习</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo+Next主题 文章添加阅读次数，访问量等]]></title>
    <url>%2F2017%2F10%2F06%2FHexo-Next%E4%B8%BB%E9%A2%98-%E6%96%87%E7%AB%A0%E6%B7%BB%E5%8A%A0%E9%98%85%E8%AF%BB%E6%AC%A1%E6%95%B0%EF%BC%8C%E8%AE%BF%E9%97%AE%E9%87%8F%E7%AD%89%2F</url>
    <content type="text"><![CDATA[本章所讲给文章设置阅读量，启用不蒜子统计，仅限于文章页面显示阅读书，在首页不显示。效果如下图所示： 打开 Hexo 目录下的 \themes\next\ _config.yml 文件 /** * RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS. * LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/ (function() { // DON'T EDIT BELOW THIS LINE var d = document, s = d.createElement('script'); s.src = 'https://https-xrlrf-github-io.disqus.com/embed.js'; s.setAttribute('data-timestamp', +new Date()); (d.head || d.body).appendChild(s); })(); Please enable JavaScript to view the comments powered by Disqus. window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-107582762-1');]]></content>
      <categories>
        <category>Hexo学习</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown 编辑器： remarkable 安装(ubuntu)]]></title>
    <url>%2F2017%2F10%2F06%2Fmarkdown-%E7%BC%96%E8%BE%91%E5%99%A8%EF%BC%9A-remarkable-%E5%AE%89%E8%A3%85-ubuntu%2F</url>
    <content type="text"><![CDATA[下载安装包 http://remarkableapp.github.io/linux/download.html 安装之： 1dpkg -i remarkable_1.62_all.deb 补上依赖项： 1sudo apt-get install -f 运行： 1remarkable &amp; /** * RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS. * LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/ (function() { // DON'T EDIT BELOW THIS LINE var d = document, s = d.createElement('script'); s.src = 'https://https-xrlrf-github-io.disqus.com/embed.js'; s.setAttribute('data-timestamp', +new Date()); (d.head || d.body).appendChild(s); })(); Please enable JavaScript to view the comments powered by Disqus. window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-107582762-1');]]></content>
      <categories>
        <category>安装软件</category>
      </categories>
      <tags>
        <tag>软件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客搭建（next主题系列详解）]]></title>
    <url>%2F2017%2F10%2F06%2FHexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%EF%BC%88next%E4%B8%BB%E9%A2%98%E7%B3%BB%E5%88%97%E8%AF%A6%E8%A7%A3%EF%BC%89%2F</url>
    <content type="text"><![CDATA[hexo的next主题配置详解 /** * RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS. * LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/ (function() { // DON'T EDIT BELOW THIS LINE var d = document, s = d.createElement('script'); s.src = 'https://https-xrlrf-github-io.disqus.com/embed.js'; s.setAttribute('data-timestamp', +new Date()); (d.head || d.body).appendChild(s); })(); Please enable JavaScript to view the comments powered by Disqus. window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-107582762-1');]]></content>
      <categories>
        <category>Hexo学习</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客使用系列（四）——文章里嵌入音乐播放器]]></title>
    <url>%2F2017%2F10%2F05%2FHexo%E5%8D%9A%E5%AE%A2%E4%BD%BF%E7%94%A8%E7%B3%BB%E5%88%97%EF%BC%88%E5%9B%9B%EF%BC%89%E2%80%94%E2%80%94%E6%96%87%E7%AB%A0%E9%87%8C%E5%B5%8C%E5%85%A5%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A8%2F</url>
    <content type="text"><![CDATA[内嵌播放器 打开网页版网易云选择自己喜欢的音乐或歌单，点开歌曲名或者歌单名，点击生成外链播放器，赋值html代码，将html代码无需任何修改放入markdown文章就可以了。可以取消自动播放。 /** * RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS. * LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/ (function() { // DON'T EDIT BELOW THIS LINE var d = document, s = d.createElement('script'); s.src = 'https://https-xrlrf-github-io.disqus.com/embed.js'; s.setAttribute('data-timestamp', +new Date()); (d.head || d.body).appendChild(s); })(); Please enable JavaScript to view the comments powered by Disqus. window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-107582762-1');]]></content>
      <categories>
        <category>hexo学习</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python/Django生成二维码]]></title>
    <url>%2F2017%2F10%2F05%2FPython%E7%94%9F%E6%88%90%E4%BA%8C%E7%BB%B4%E7%A0%81%2F</url>
    <content type="text"><![CDATA[开始安装1.1 用Python来生成二维码很简单，可以看 qrcode 这个包：1pip install qrcode qrcode 依赖 Image 这个包： 1pip install Image 1.2 安装后就可以使用了，这个程序带了一个 qr 命令：1qr 'http://www.ziqiangxuetang.com' &gt; test.png 1.3 下面我们看一下如何在 代码 中使用1234567import qrcodeimg = qrcode.make('http://www.tuweizhong.com')# img &lt;qrcode.image.pil.PilImage object at 0x1044ed9d0&gt;with open('test.png', 'wb') as f: img.save(f) 安装： 12pip install git+git://github.com/ojii/pymaging.git#egg=pymagingpip install git+git://github.com/ojii/pymaging-png.git#egg=pymaging-png 使用方法大致相同，命令行上： 1qr --factory=pymaging "Some text" &gt; test.png Python中调用： 123import qrcodefrom qrcode.image.pure import PymagingImageimg = qrcode.make('Some data here', image_factory=PymagingImage) /** * RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS. * LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/ /* var disqus_config = function () { this.page.url = PAGE_URL; // Replace PAGE_URL with your page's canonical URL variable this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable }; */ (function() { // DON'T EDIT BELOW THIS LINE var d = document, s = d.createElement('script'); s.src = 'https://https-xrlrf-github-io.disqus.com/embed.js'; s.setAttribute('data-timestamp', +new Date()); (d.head || d.body).appendChild(s); })(); Please enable JavaScript to view the comments powered by Disqus. window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-107582762-1'); /** * RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS. * LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/ (function() { // DON'T EDIT BELOW THIS LINE var d = document, s = d.createElement('script'); s.src = 'https://https-xrlrf-github-io.disqus.com/embed.js'; s.setAttribute('data-timestamp', +new Date()); (d.head || d.body).appendChild(s); })(); Please enable JavaScript to view the comments powered by Disqus. window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-107582762-1');]]></content>
      <categories>
        <category>Python学习</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
</search>
